{"ast":null,"code":"/**-----------------------------------------------------------------------------------------\n* Copyright © 2021 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport { __decorate, __param, __metadata } from 'tslib';\nimport { Injectable, InjectionToken, Inject, Optional, NgZone, EventEmitter, isDevMode, Input, ElementRef, Output, ViewChild, Component, Renderer2, TemplateRef, ApplicationRef, ComponentFactoryResolver, Injector, NgModule } from '@angular/core';\nimport { siblingContainer, parents, addScroll, align, boundingOffset, offset, positionWithScroll, removeScroll, restrictToView, scrollPosition, getWindowViewPort } from '@progress/kendo-popup-common';\nimport { isDocumentAvailable, hasObservers, ResizeSensorComponent, ResizeSensorModule } from '@progress/kendo-angular-common';\nimport { fromEvent, merge, from } from 'rxjs';\nimport { auditTime } from 'rxjs/operators';\nimport { style, animate, AnimationBuilder } from '@angular/animations';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { CommonModule } from '@angular/common';\n/**\n * @hidden\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/animations';\nimport * as ɵngcc2 from '@angular/common';\nimport * as ɵngcc3 from '@progress/kendo-angular-common';\nconst _c0 = [\"container\"];\n\nfunction PopupComponent_ng_template_3_Template(rf, ctx) {}\n\nconst _c1 = [\"*\"];\n\nconst eitherRect = (rect, offset$$1) => {\n  if (!rect) {\n    return {\n      height: 0,\n      left: offset$$1.left,\n      top: offset$$1.top,\n      width: 0\n    };\n  }\n\n  return rect;\n};\n/**\n * @hidden\n */\n\n\nconst removeStackingOffset = (rect, stackingOffset) => {\n  if (!stackingOffset) {\n    return rect;\n  }\n\n  const result = {\n    height: rect.height,\n    left: rect.left - stackingOffset.left,\n    top: rect.top - stackingOffset.top,\n    width: rect.width\n  };\n  return result;\n};\n/**\n * @hidden\n */\n\n\nconst isDifferentOffset = (oldOffset, newOffset) => {\n  const {\n    left: oldLeft,\n    top: oldTop\n  } = oldOffset;\n  const {\n    left: newLeft,\n    top: newTop\n  } = newOffset;\n  return Math.abs(oldLeft - newLeft) >= 1 || Math.abs(oldTop - newTop) >= 1;\n};\n/**\n * @hidden\n */\n\n\nconst isWindowAvailable = () => {\n  return typeof window !== 'undefined';\n};\n/**\n * @hidden\n */\n\n\nconst OVERFLOW_REGEXP = /auto|scroll/;\n\nconst overflowElementStyle = element => {\n  return `${element.style.overflow}${element.style.overflowX}${element.style.overflowY}`;\n};\n\nconst overflowComputedStyle = element => {\n  const styles = window.getComputedStyle(element);\n  return `${styles.overflow}${styles.overflowX}${styles.overflowY}`;\n};\n\nconst overflowStyle = element => {\n  return overflowElementStyle(element) || overflowComputedStyle(element);\n};\n/**\n * @hidden\n */\n\n\nconst scrollableParents = element => {\n  const parentElements = [];\n\n  if (!isDocumentAvailable() || !isWindowAvailable()) {\n    return parentElements;\n  }\n\n  let parent = element.parentElement;\n\n  while (parent) {\n    if (OVERFLOW_REGEXP.test(overflowStyle(parent)) || parent.hasAttribute('data-scrollable')) {\n      parentElements.push(parent);\n    }\n\n    parent = parent.parentElement;\n  }\n\n  parentElements.push(window);\n  return parentElements;\n};\n/**\n * @hidden\n */\n\n\nconst FRAME_DURATION = 1000 / 60; //1000ms divided by 60fps\n\nfunction memoize(fun) {\n  let result;\n  let called = false;\n  return (...args) => {\n    if (called) {\n      return result;\n    }\n\n    result = fun(...args);\n    called = true;\n    return result;\n  };\n}\n\nconst ɵ3 = () => {\n  if (!isDocumentAvailable() && document.body !== null) {\n    return false;\n  }\n\n  const top = 10;\n  const parent = document.createElement(\"div\");\n  parent.style.transform = \"matrix(10, 0, 0, 10, 0, 0)\";\n  parent.innerHTML = `<div style=\"position: fixed; top: ${top}px;\">child</div>`;\n  document.body.appendChild(parent);\n  const isDifferent = parent.children[0].getBoundingClientRect().top !== top;\n  document.body.removeChild(parent);\n  return isDifferent;\n};\n/**\n * @hidden\n */\n\n\nconst hasRelativeStackingContext = memoize(ɵ3);\n/**\n * @hidden\n */\n\nconst zIndex = (anchor, container) => {\n  if (!anchor || !isDocumentAvailable() || !isWindowAvailable()) {\n    return null;\n  }\n\n  const sibling = siblingContainer(anchor, container);\n\n  if (!sibling) {\n    return null;\n  }\n\n  const result = [anchor].concat(parents(anchor, sibling)).reduce((index, p) => {\n    const zIndexStyle = p.style.zIndex || window.getComputedStyle(p).zIndex;\n    const current = parseInt(zIndexStyle, 10);\n    return current > index ? current : index;\n  }, 0);\n  return result ? result + 1 : null;\n};\n/**\n * @hidden\n */\n\n\nconst scaleRect = (rect, scale) => {\n  if (!rect || scale === 1) {\n    return rect;\n  }\n\n  return {\n    height: rect.height / scale,\n    left: rect.left / scale,\n    top: rect.top / scale,\n    width: rect.width / scale\n  };\n};\n\nconst STYLES = ['font-size', 'font-family', 'font-stretch', 'font-style', 'font-weight', 'line-height'];\n/**\n * @hidden\n */\n\nlet DOMService = /*#__PURE__*/(() => {\n  let DOMService = class DOMService {\n    addOffset(current, addition) {\n      return {\n        left: current.left + addition.left,\n        top: current.top + addition.top\n      };\n    }\n\n    addScroll(rect, scroll) {\n      return addScroll(rect, scroll);\n    }\n\n    align(settings) {\n      return align(settings);\n    }\n\n    boundingOffset(el) {\n      return boundingOffset(this.nativeElement(el));\n    }\n\n    getFontStyles(el) {\n      const window = this.getWindow();\n\n      if (!window || !el) {\n        return [];\n      }\n\n      const computedStyles = window.getComputedStyle(this.nativeElement(el));\n      return STYLES.map(font => ({\n        key: font,\n        value: computedStyles[font]\n      }));\n    }\n\n    getWindow() {\n      return isWindowAvailable() ? window : null;\n    }\n\n    hasOffsetParent(el) {\n      if (!el) {\n        return false;\n      }\n\n      return !!this.nativeElement(el).offsetParent;\n    }\n\n    offset(el) {\n      if (!el) {\n        return null;\n      }\n\n      return offset(this.nativeElement(el));\n    }\n\n    offsetAtPoint(el, currentLocation) {\n      if (!el) {\n        return null;\n      }\n\n      const element = this.nativeElement(el);\n      const {\n        left,\n        top,\n        transition\n      } = element.style;\n      element.style.transition = 'none';\n      element.style.left = `${currentLocation.left}px`;\n      element.style.top = `${currentLocation.top}px`;\n      const currentOffset = offset(element);\n      element.style.left = left;\n      element.style.top = top; // prevents elements with transition to be animated because of the change\n      // tslint:disable-next-line:no-unused-expression\n\n      element.offsetHeight;\n      element.style.transition = transition;\n      return currentOffset;\n    }\n\n    nativeElement(el) {\n      if (!el) {\n        return null;\n      }\n\n      return el.nativeElement || el;\n    }\n\n    position(element, popup, scale = 1) {\n      if (!element || !popup) {\n        return null;\n      }\n\n      return positionWithScroll(this.nativeElement(element), this.nativeElement(popup), scale);\n    }\n\n    removeScroll(rect, scroll) {\n      return removeScroll(rect, scroll);\n    }\n\n    restrictToView(settings) {\n      return restrictToView(settings);\n    }\n\n    scrollPosition(el) {\n      return scrollPosition(this.nativeElement(el));\n    }\n\n    scrollableParents(el) {\n      return scrollableParents(this.nativeElement(el));\n    }\n\n    stackingElementOffset(el) {\n      const relativeContextElement = this.getRelativeContextElement(el);\n\n      if (!relativeContextElement) {\n        return null;\n      }\n\n      return offset(relativeContextElement);\n    }\n\n    stackingElementScroll(el) {\n      const relativeContextElement = this.getRelativeContextElement(el);\n\n      if (!relativeContextElement) {\n        return {\n          x: 0,\n          y: 0\n        };\n      }\n\n      return {\n        x: relativeContextElement.scrollLeft,\n        y: relativeContextElement.scrollTop\n      };\n    }\n\n    getRelativeContextElement(el) {\n      if (!el || !hasRelativeStackingContext()) {\n        return null;\n      }\n\n      let parent = this.nativeElement(el).parentElement;\n\n      while (parent) {\n        if (window.getComputedStyle(parent).transform !== 'none') {\n          return parent;\n        }\n\n        parent = parent.parentElement;\n      }\n\n      return null;\n    }\n\n    useRelativePosition(el) {\n      return !!this.getRelativeContextElement(el);\n    }\n\n    windowViewPort(el) {\n      return getWindowViewPort(this.nativeElement(el));\n    }\n\n    zIndex(anchor, container) {\n      return zIndex(this.nativeElement(anchor), this.nativeElement(container));\n    }\n\n    zoomLevel() {\n      if (!isDocumentAvailable() || !isWindowAvailable()) {\n        return 1;\n      }\n\n      return parseFloat((document.documentElement.clientWidth / window.innerWidth).toFixed(2)) || 1;\n    }\n\n    isZoomed() {\n      return this.zoomLevel() > 1;\n    }\n\n  };\n\n  DOMService.ɵfac = function DOMService_Factory(t) {\n    return new (t || DOMService)();\n  };\n\n  DOMService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: DOMService,\n    factory: function (t) {\n      return DOMService.ɵfac(t);\n    }\n  });\n  /**\n   * Used to set the document scale when using a [scale transform](https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scale).\n   *\n   * The document or container scale is required to compute the popup position correctly. Detecting the scale is not reliable and must be set by providing a value for SCALE. See [Support for Document Scale]({% slug documentscale_popup %}).\n   *\n   * > Using this token is not necessary for user-applied browser zoom.\n   *\n   * {% meta height:300 %}\n   * {% embed_file scale/app.component.ts preview %}\n   * {% embed_file shared/app.module.ts %}\n   * {% embed_file shared/main.ts %}\n   * {% endmeta %}\n   *\n   *\n   */\n\n  return DOMService;\n})();\nconst SCALE = new InjectionToken('Popup Document Scale');\n/**\n * @hidden\n */\n\nlet AlignService = /*#__PURE__*/(() => {\n  let AlignService = class AlignService {\n    constructor(_dom, scale = 1) {\n      this._dom = _dom;\n      this.scale = scale;\n    }\n\n    alignElement(settings) {\n      const {\n        anchor,\n        element,\n        anchorAlign,\n        elementAlign,\n        margin,\n        offset: offset$$1,\n        positionMode\n      } = settings;\n      const scale = this.scale || 1;\n      const fixedMode = positionMode === 'fixed' || !this._dom.hasOffsetParent(element);\n      const anchorRect = fixedMode ? this.absoluteRect(anchor, element, offset$$1, scale) : this.relativeRect(anchor, element, offset$$1, scale);\n      const elementRect = scaleRect(this._dom.offset(element), scale);\n\n      const result = this._dom.align({\n        anchorAlign: anchorAlign,\n        anchorRect: anchorRect,\n        elementAlign: elementAlign,\n        elementRect: elementRect,\n        margin\n      });\n\n      return result;\n    }\n\n    absoluteRect(anchor, element, offset$$1, scale) {\n      const scrollPos = this.elementScrollPosition(anchor, element);\n      const rect = eitherRect(this._dom.offset(anchor), offset$$1);\n      const stackScale = 2 * scale;\n\n      const stackScroll = this._dom.stackingElementScroll(element);\n\n      if (scale !== 1 && stackScroll) {\n        stackScroll.x /= stackScale;\n        stackScroll.y /= stackScale;\n      }\n\n      const stackOffset = this._dom.stackingElementOffset(element);\n\n      if (scale !== 1 && stackOffset) {\n        stackOffset.left /= stackScale;\n        stackOffset.top /= stackScale;\n      }\n\n      return this._dom.removeScroll(this._dom.addScroll(removeStackingOffset(scaleRect(rect, scale), stackOffset), stackScroll), scrollPos);\n    }\n\n    elementScrollPosition(anchor, element) {\n      return anchor ? {\n        x: 0,\n        y: 0\n      } : this._dom.scrollPosition(element);\n    }\n\n    relativeRect(anchor, element, offset$$1, scale) {\n      const rect = eitherRect(this._dom.position(anchor, element, scale), offset$$1);\n      return scaleRect(rect, scale);\n    }\n\n  };\n\n  AlignService.ɵfac = function AlignService_Factory(t) {\n    return new (t || AlignService)(ɵngcc0.ɵɵinject(DOMService), ɵngcc0.ɵɵinject(SCALE, 8));\n  };\n\n  AlignService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: AlignService,\n    factory: function (t) {\n      return AlignService.ɵfac(t);\n    }\n  });\n  AlignService = __decorate([__param(1, Inject(SCALE)), __param(1, Optional()), __metadata(\"design:paramtypes\", [DOMService, Number])], AlignService);\n  /**\n   * @hidden\n   */\n\n  return AlignService;\n})();\nlet PositionService = /*#__PURE__*/(() => {\n  let PositionService = class PositionService {\n    constructor(_dom, scale = 1) {\n      this._dom = _dom;\n      this.scale = scale;\n    }\n\n    positionElement(settings) {\n      const {\n        anchor,\n        currentLocation,\n        element,\n        anchorAlign,\n        elementAlign,\n        collisions,\n        margin\n      } = settings;\n      const dom = this._dom;\n      const scale = this.scale || 1;\n      const elementOffset = dom.offsetAtPoint(element, currentLocation);\n      const elementRect = scaleRect(elementOffset, scale);\n      const anchorOffset = scaleRect(dom.offset(anchor), scale);\n      const anchorRect = eitherRect(anchorOffset, currentLocation);\n      const viewPort = settings.viewPort || dom.windowViewPort(element);\n      viewPort.width = viewPort.width / scale;\n      viewPort.height = viewPort.height / scale;\n      const result = dom.restrictToView({\n        anchorAlign,\n        anchorRect,\n        collisions,\n        elementAlign,\n        elementRect,\n        margin,\n        viewPort\n      });\n      const offset$$1 = dom.addOffset(currentLocation, result.offset);\n      return {\n        flip: result.flip,\n        flipped: result.flipped,\n        offset: offset$$1\n      };\n    }\n\n  };\n\n  PositionService.ɵfac = function PositionService_Factory(t) {\n    return new (t || PositionService)(ɵngcc0.ɵɵinject(DOMService), ɵngcc0.ɵɵinject(SCALE, 8));\n  };\n\n  PositionService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: PositionService,\n    factory: function (t) {\n      return PositionService.ɵfac(t);\n    }\n  });\n  PositionService = __decorate([__param(1, Inject(SCALE)), __param(1, Optional()), __metadata(\"design:paramtypes\", [DOMService, Number])], PositionService);\n  /**\n   * @hidden\n   */\n\n  return PositionService;\n})();\nlet ResizeService = /*#__PURE__*/(() => {\n  let ResizeService = class ResizeService {\n    constructor(_dom, _zone) {\n      this._dom = _dom;\n      this._zone = _zone;\n    }\n\n    subscribe(callback) {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      this._zone.runOutsideAngular(() => {\n        this.subscription = fromEvent(this._dom.getWindow(), \"resize\").pipe(auditTime(FRAME_DURATION)).subscribe(() => callback());\n      });\n    }\n\n    unsubscribe() {\n      if (!this.subscription) {\n        return;\n      }\n\n      this.subscription.unsubscribe();\n    }\n\n    isUnsubscribed() {\n      return this.subscription && this.subscription.closed;\n    }\n\n  };\n\n  ResizeService.ɵfac = function ResizeService_Factory(t) {\n    return new (t || ResizeService)(ɵngcc0.ɵɵinject(DOMService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n  };\n\n  ResizeService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: ResizeService,\n    factory: function (t) {\n      return ResizeService.ɵfac(t);\n    }\n  });\n  ResizeService = __decorate([__metadata(\"design:paramtypes\", [DOMService, NgZone])], ResizeService);\n  /**\n   * @hidden\n   */\n\n  return ResizeService;\n})();\nconst THRESHOLD_DIFF = 1;\n/**\n * @hidden\n */\n\nlet ScrollableService = /*#__PURE__*/(() => {\n  let ScrollableService = class ScrollableService {\n    constructor(_dom, _zone) {\n      this._dom = _dom;\n      this._zone = _zone;\n    }\n\n    forElement(element) {\n      this.unsubscribe();\n      this.element = element;\n      return this;\n    }\n\n    subscribe(callback) {\n      if (!callback || !isDocumentAvailable() || !this.element) {\n        return;\n      }\n\n      const nativeElement = this._dom.nativeElement(this.element);\n\n      const parents$$1 = this._dom.scrollableParents(this.element);\n\n      this._zone.runOutsideAngular(() => {\n        const observables = parents$$1.map(p => fromEvent(p, \"scroll\").pipe(auditTime(FRAME_DURATION)));\n\n        const subscriber = e => {\n          const target = e.target;\n          const isParent = parents$$1.filter(p => p === target).length > 0;\n          const isDocument = target === document;\n          const isWindow = target === window;\n\n          if (isParent || isDocument || isWindow) {\n            callback(this.isVisible(nativeElement, target));\n          }\n        };\n\n        this.subscription = merge(...observables).subscribe(subscriber);\n      });\n    }\n\n    unsubscribe() {\n      if (!this.subscription) {\n        return;\n      }\n\n      this.subscription.unsubscribe();\n    }\n\n    isVisible(elem, container) {\n      const elemRect = this._dom.boundingOffset(elem);\n\n      const containerRect = this._dom.boundingOffset(container);\n\n      if (THRESHOLD_DIFF < containerRect.top - elemRect.bottom) {\n        return false;\n      }\n\n      if (THRESHOLD_DIFF < elemRect.top - containerRect.bottom) {\n        return false;\n      }\n\n      if (THRESHOLD_DIFF < elemRect.left - containerRect.right) {\n        return false;\n      }\n\n      if (THRESHOLD_DIFF < containerRect.left - elemRect.right) {\n        return false;\n      }\n\n      return true;\n    }\n\n  };\n\n  ScrollableService.ɵfac = function ScrollableService_Factory(t) {\n    return new (t || ScrollableService)(ɵngcc0.ɵɵinject(DOMService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n  };\n\n  ScrollableService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: ScrollableService,\n    factory: function (t) {\n      return ScrollableService.ɵfac(t);\n    }\n  });\n  ScrollableService = __decorate([__metadata(\"design:paramtypes\", [DOMService, NgZone])], ScrollableService);\n  return ScrollableService;\n})();\nconst LEFT = 'left';\nconst RIGHT = 'right';\nconst DOWN = 'down';\nconst UP = 'up';\nconst DEFAULT_TYPE = 'slide';\nconst DEFAULT_DURATION = 100;\nconst animationTypes = {};\n/* tslint:disable:object-literal-sort-keys */\n\nanimationTypes.expand = direction => {\n  const scale = direction === UP || direction === DOWN ? 'scaleY' : 'scaleX';\n  const startScale = 0;\n  const endScale = 1;\n  let origin;\n\n  if (direction === DOWN) {\n    origin = 'top';\n  } else if (direction === LEFT) {\n    origin = RIGHT;\n  } else if (direction === RIGHT) {\n    origin = LEFT;\n  } else {\n    origin = 'bottom';\n  }\n\n  return {\n    start: {\n      transform: `${scale}(${startScale})`,\n      transformOrigin: origin\n    },\n    end: {\n      transform: `${scale}(${endScale})`\n    }\n  };\n};\n\nanimationTypes.slide = direction => {\n  const translate = direction === LEFT || direction === RIGHT ? 'translateX' : 'translateY';\n  const start = direction === RIGHT || direction === DOWN ? -100 : 100;\n  const end = 0;\n  return {\n    start: {\n      transform: `${translate}(${start}%)`\n    },\n    end: {\n      transform: `${translate}(${end}%)`\n    }\n  };\n};\n\nanimationTypes.fade = () => {\n  return {\n    start: {\n      opacity: 0\n    },\n    end: {\n      opacity: 1\n    }\n  };\n};\n\nanimationTypes.zoom = () => {\n  const start = 0;\n  const end = 1;\n  return {\n    start: {\n      transform: `scale(${start})`\n    },\n    end: {\n      transform: `scale(${end})`\n    }\n  };\n};\n/**\n * @hidden\n */\n\n\nlet AnimationService = /*#__PURE__*/(() => {\n  let AnimationService = class AnimationService {\n    constructor(animationBuilder) {\n      this.animationBuilder = animationBuilder;\n      this.start = new EventEmitter();\n      this.end = new EventEmitter();\n    }\n\n    play(element, options, flip) {\n      if (!this.flip || this.flip.horizontal !== flip.horizontal || this.flip.vertical !== flip.vertical) {\n        this.flip = flip;\n        const type = options.type || DEFAULT_TYPE;\n        const statesFn = animationTypes[type];\n\n        if (statesFn) {\n          const direction = this.getDirection(flip, options);\n          const states = statesFn(direction);\n          this.playStates(element, states, options);\n        } else if (isDevMode()) {\n          throw new Error(`Unsupported animation type: \"${type}\". The supported types are slide, expand, fade and zoom.`);\n        }\n      }\n    }\n\n    ngOnDestroy() {\n      this.stopPlayer();\n    }\n\n    playStates(element, states, options) {\n      this.stopPlayer();\n      const duration = options.duration || DEFAULT_DURATION;\n      const factory = this.animationBuilder.build([style(states.start), animate(`${duration}ms ease-in`, style(states.end))]);\n      const player = this.player = factory.create(element);\n      player.onDone(() => {\n        this.end.emit();\n        this.stopPlayer();\n      });\n      this.start.emit();\n      player.play();\n    }\n\n    getDirection(flip, options) {\n      let direction = options.direction || DOWN;\n\n      if (flip.horizontal) {\n        if (direction === LEFT) {\n          direction = RIGHT;\n        } else if (direction === RIGHT) {\n          direction = LEFT;\n        }\n      }\n\n      if (flip.vertical) {\n        if (direction === DOWN) {\n          direction = UP;\n        } else if (direction === UP) {\n          direction = DOWN;\n        }\n      }\n\n      return direction;\n    }\n\n    stopPlayer() {\n      if (this.player) {\n        this.player.destroy();\n        this.player = null;\n      }\n    }\n\n  };\n\n  AnimationService.ɵfac = function AnimationService_Factory(t) {\n    return new (t || AnimationService)(ɵngcc0.ɵɵinject(ɵngcc1.AnimationBuilder));\n  };\n\n  AnimationService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: AnimationService,\n    factory: function (t) {\n      return AnimationService.ɵfac(t);\n    }\n  });\n  AnimationService = __decorate([__metadata(\"design:paramtypes\", [AnimationBuilder])], AnimationService);\n  /**\n   * @hidden\n   */\n\n  return AnimationService;\n})();\nconst packageMetadata = {\n  name: '@progress/kendo-angular-popup',\n  productName: 'Kendo UI for Angular',\n  productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],\n  publishDate: 1635939378,\n  version: '',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'\n};\nconst DEFAULT_OFFSET = {\n  left: -10000,\n  top: 0\n};\nconst ANIMATION_CONTAINER = 'k-animation-container';\nconst ANIMATION_CONTAINER_FIXED = 'k-animation-container-fixed';\n/**\n * Represents the [Kendo UI Popup component for Angular]({% slug overview_popup %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <button #anchor (click)=\"show=!show\">Toggle</button>\n *  <kendo-popup *ngIf=\"show\" [anchor]=\"anchor\">\n *      <strong>Popup content!</strong>\n *  </kendo-popup>\n * `\n * })\n * class AppComponent {\n *   public show: boolean = false;\n * }\n * ```\n */\n\nlet PopupComponent = /*#__PURE__*/(() => {\n  let PopupComponent = class PopupComponent {\n    constructor(container, _alignService, domService, _positionService, _resizeService, _scrollableService, animationService, _renderer, _zone) {\n      this.container = container;\n      this._alignService = _alignService;\n      this.domService = domService;\n      this._positionService = _positionService;\n      this._resizeService = _resizeService;\n      this._scrollableService = _scrollableService;\n      this.animationService = animationService;\n      this._renderer = _renderer;\n      this._zone = _zone;\n      /**\n       * Controls the Popup animation. By default, the opening and closing animations\n       * are enabled ([see example]({% slug animations_popup %})).\n       */\n\n      this.animate = true;\n      /**\n       * Specifies the anchor pivot point\n       * ([see example]({% slug alignmentpositioning_popup %}#toc-positioning)).\n       */\n\n      this.anchorAlign = {\n        horizontal: 'left',\n        vertical: 'bottom'\n      };\n      /**\n       * Configures the collision behavior of the Popup\n       * ([see example]({% slug viewportboundarydetection_popup %})).\n       */\n\n      this.collision = {\n        horizontal: 'fit',\n        vertical: 'flip'\n      };\n      /**\n       * Specifies the pivot point of the Popup\n       * ([see example]({% slug alignmentpositioning_popup %}#toc-positioning)).\n       */\n\n      this.popupAlign = {\n        horizontal: 'left',\n        vertical: 'top'\n      };\n      /**\n       * Controls whether the component will copy the `anchor` font styles.\n       */\n\n      this.copyAnchorStyles = false;\n      /**\n       * Specifies the position mode of the component. By default, the Popup uses fixed positioning.\n       * To make the Popup acquire absolute positioning, set this option to `absolute`.\n       *\n       * > If you need to support mobile browsers with the zoom option,\n       * use the `absolute` positioning of the Popup.\n       *\n       * @example\n       * ```html\n       * <style>\n       *  .parent-content {\n       *     position: relative;\n       *     width: 200px;\n       *     height: 200px;\n       *     overflow: auto;\n       *     margin: 200px auto;\n       *     border: 1px solid red;\n       *  }\n       *  .content {\n       *     position: relative;\n       *     width: 100px;\n       *     height: 100px;\n       *     overflow: auto;\n       *     margin: 300px;\n       *     border: 1px solid blue;\n       *  }\n       *  .anchor {\n       *     position: absolute;\n       *     top: 200px;\n       *     left: 200px;\n       *  }\n       * </style>\n       * ```\n       * ```ts\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *   <div class=\"example-config\">\n       *      Position mode:\n       *      <label><input type=\"radio\" value=\"fixed\" [(ngModel)]=\"mode\" /> Fixed</label>\n       *      <label><input type=\"radio\" value=\"absolute\" [(ngModel)]=\"mode\" /> Absolute</label>\n       *   </div>\n       *   <div class=\"example-config\">\n       *       Append to\n       *       <label>\n       *           <input type=\"radio\" name=\"place\" [value]=\"1\" [(ngModel)]=\"checked\" />\n       *           Root component\n       *       </label>\n       *       <label>\n       *           <input type=\"radio\" name=\"place\" [value]=\"2\" [(ngModel)]=\"checked\" />\n       *           <span style=\"color: red\">Red Container</span>\n       *       </label>\n       *       <label>\n       *           <input type=\"radio\" name=\"place\" [value]=\"3\" [(ngModel)]=\"checked\" />\n       *           <span style=\"color: blue\">Blue Container</span>\n       *       </label>\n       *   </div>\n       *   <div class=\"example\">\n       *     <div class=\"parent-content\" [scrollLeft]=\"250\" [scrollTop]=\"230\">\n       *         <div class=\"content\" [scrollLeft]=\"170\" [scrollTop]=\"165\">\n       *           <button #anchor class=\"anchor\" (click)=\"show = !show\">Toggle</button>\n       *           <kendo-popup [positionMode]=\"mode\" [anchor]=\"anchor\" (anchorViewportLeave)=\"show=false\" *ngIf=\"show && checked === 3\">\n       *             <ul>\n       *                 <li>Item1</li>\n       *                 <li>Item2</li>\n       *                 <li>Item3</li>\n       *             </ul>\n       *           </kendo-popup>\n       *           <span style=\"position: absolute; top: 400px; left: 400px\">Bottom/Right</span>\n       *         </div>\n       *         <kendo-popup [positionMode]=\"mode\" [anchor]=\"anchor\" (anchorViewportLeave)=\"show=false\" *ngIf=\"show && checked === 2\">\n       *           <ul>\n       *               <li>Item1</li>\n       *               <li>Item2</li>\n       *               <li>Item3</li>\n       *           </ul>\n       *         </kendo-popup>\n       *         <span style=\"position: absolute; top: 600px; left: 600px\">Bottom/Right</span>\n       *     </div>\n       *     <kendo-popup [positionMode]=\"mode\" [anchor]=\"anchor\" (anchorViewportLeave)=\"show=false\" *ngIf=\"show && checked === 1\">\n       *       <ul>\n       *           <li>Item1</li>\n       *           <li>Item2</li>\n       *           <li>Item3</li>\n       *       </ul>\n       *     </kendo-popup>\n       *   </div>\n       * `\n       * })\n       * class AppComponent {\n       *   public checked: number = 3;\n       *   public mode: string = 'absolute';\n       *   public show: boolean = true;\n       * }\n       * ```\n       */\n\n      this.positionMode = 'fixed';\n      /**\n       * Specifies the absolute position of the element\n       * ([see example]({% slug alignmentpositioning_popup %}#toc-aligning-to-absolute-points)).\n       * The Popup opens next to that point. The Popup pivot point is defined by the `popupAlign` configuration option.\n       * The boundary detection is applied by using the window viewport.\n       */\n\n      this.offset = DEFAULT_OFFSET;\n      /**\n       * Fires when the anchor is scrolled outside the screen boundaries.\n       * ([see example]({% slug closing_popup %}#toc-after-leaving-the-viewport)).\n       */\n\n      this.anchorViewportLeave = new EventEmitter();\n      /**\n       * Fires after the component is closed.\n       */\n\n      this.close = new EventEmitter();\n      /**\n       * Fires after the component is opened and the opening animation ends.\n       */\n\n      this.open = new EventEmitter();\n      /**\n       * Fires after the component is opened and the Popup is positioned.\n       */\n\n      this.positionChange = new EventEmitter();\n      this.resolvedPromise = Promise.resolve(null);\n      this.initialCheck = true;\n      validatePackage(packageMetadata);\n\n      this._renderer.addClass(container.nativeElement, ANIMATION_CONTAINER);\n\n      this.updateFixedClass();\n    }\n\n    ngOnInit() {\n      this.reposition = this.reposition.bind(this);\n\n      this._resizeService.subscribe(this.reposition);\n\n      this.animationSubscriptions = this.animationService.start.subscribe(this.onAnimationStart.bind(this));\n      this.animationSubscriptions.add(this.animationService.end.subscribe(this.onAnimationEnd.bind(this)));\n\n      this._scrollableService.forElement(this.anchor || this.container).subscribe(this.onScroll.bind(this));\n\n      this.currentOffset = DEFAULT_OFFSET;\n      this.setZIndex();\n      this.copyFontStyles();\n      this.updateFixedClass();\n    }\n\n    ngOnChanges(changes) {\n      if (changes.copyAnchorStyles) {\n        this.copyFontStyles();\n      }\n\n      if (changes.positionMode) {\n        this.updateFixedClass();\n      }\n    }\n\n    ngAfterViewInit() {\n      this.reposition();\n\n      if (!this.animate) {\n        this.resolvedPromise.then(() => {\n          this.onAnimationEnd();\n        });\n      }\n    }\n\n    ngAfterViewChecked() {\n      if (this.initialCheck) {\n        this.initialCheck = false;\n        return;\n      }\n\n      this._zone.runOutsideAngular(() => {\n        // workarounds https://github.com/angular/angular/issues/19094\n        // uses promise because it is executed synchronously after the content is updated\n        // does not use onStable in case the current zone is not the angular one.\n        this.unsubscribeReposition();\n        this.repositionSubscription = from(this.resolvedPromise).subscribe(this.reposition);\n      });\n    }\n\n    ngOnDestroy() {\n      this.anchorViewportLeave.complete();\n      this.positionChange.complete();\n      this.close.emit();\n      this.close.complete();\n\n      this._resizeService.unsubscribe();\n\n      this._scrollableService.unsubscribe();\n\n      this.animationSubscriptions.unsubscribe();\n      this.unsubscribeReposition();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onResize() {\n      this.reposition();\n    }\n\n    onAnimationStart() {\n      this._renderer.removeClass(this.container.nativeElement, 'k-animation-container-shown');\n    }\n\n    onAnimationEnd() {\n      this._renderer.addClass(this.container.nativeElement, 'k-animation-container-shown');\n\n      this.open.emit();\n      this.open.complete();\n    }\n\n    get currentOffset() {\n      return this._currentOffset;\n    }\n\n    set currentOffset(offset$$1) {\n      this.setContainerStyle('left', `${offset$$1.left}px`);\n      this.setContainerStyle('top', `${offset$$1.top}px`);\n      this._currentOffset = offset$$1;\n    }\n\n    setZIndex() {\n      if (this.anchor) {\n        this.setContainerStyle('z-index', String(this.domService.zIndex(this.anchor, this.container)));\n      }\n    }\n\n    reposition() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      const {\n        flip,\n        offset: offset$$1\n      } = this.position();\n\n      if (!this.currentOffset || isDifferentOffset(this.currentOffset, offset$$1)) {\n        this.currentOffset = offset$$1;\n\n        if (hasObservers(this.positionChange)) {\n          this._zone.run(() => this.positionChange.emit({\n            offset: offset$$1,\n            flip\n          }));\n        }\n      }\n\n      if (this.animate) {\n        this.animationService.play(this.contentContainer.nativeElement, this.animate, flip);\n      }\n\n      this.resizeSensor.acceptSize();\n    }\n\n    position() {\n      const alignedOffset = this._alignService.alignElement({\n        anchor: this.anchor,\n        anchorAlign: this.anchorAlign,\n        element: this.container,\n        elementAlign: this.popupAlign,\n        margin: this.margin,\n        offset: this.offset,\n        positionMode: this.positionMode\n      });\n\n      return this._positionService.positionElement({\n        anchor: this.anchor,\n        anchorAlign: this.anchorAlign,\n        collisions: this.collision,\n        currentLocation: alignedOffset,\n        element: this.container,\n        elementAlign: this.popupAlign,\n        margin: this.margin\n      });\n    }\n\n    onScroll(isInViewPort) {\n      const hasLeaveObservers = hasObservers(this.anchorViewportLeave);\n\n      if (isInViewPort || !hasLeaveObservers) {\n        this.reposition();\n      } else if (hasLeaveObservers) {\n        this._zone.run(() => {\n          this.anchorViewportLeave.emit();\n        });\n      }\n    }\n\n    copyFontStyles() {\n      if (!this.anchor || !this.copyAnchorStyles) {\n        return;\n      }\n\n      this.domService.getFontStyles(this.anchor).forEach(s => this.setContainerStyle(s.key, s.value));\n    }\n\n    updateFixedClass() {\n      const action = this.positionMode === 'fixed' ? 'addClass' : 'removeClass';\n\n      this._renderer[action](this.container.nativeElement, ANIMATION_CONTAINER_FIXED);\n    }\n\n    setContainerStyle(name, value) {\n      this._renderer.setStyle(this.container.nativeElement, name, value);\n    }\n\n    unsubscribeReposition() {\n      if (this.repositionSubscription) {\n        this.repositionSubscription.unsubscribe();\n      }\n    }\n\n  };\n\n  PopupComponent.ɵfac = function PopupComponent_Factory(t) {\n    return new (t || PopupComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(AlignService), ɵngcc0.ɵɵdirectiveInject(DOMService), ɵngcc0.ɵɵdirectiveInject(PositionService), ɵngcc0.ɵɵdirectiveInject(ResizeService), ɵngcc0.ɵɵdirectiveInject(ScrollableService), ɵngcc0.ɵɵdirectiveInject(AnimationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  PopupComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: PopupComponent,\n    selectors: [[\"kendo-popup\"]],\n    viewQuery: function PopupComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 7);\n        ɵngcc0.ɵɵviewQuery(ResizeSensorComponent, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentContainer = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.resizeSensor = _t.first);\n      }\n    },\n    inputs: {\n      animate: \"animate\",\n      anchorAlign: \"anchorAlign\",\n      collision: \"collision\",\n      popupAlign: \"popupAlign\",\n      copyAnchorStyles: \"copyAnchorStyles\",\n      positionMode: \"positionMode\",\n      offset: \"offset\",\n      anchor: \"anchor\",\n      popupClass: \"popupClass\",\n      margin: \"margin\"\n    },\n    outputs: {\n      anchorViewportLeave: \"anchorViewportLeave\",\n      close: \"close\",\n      open: \"open\",\n      positionChange: \"positionChange\"\n    },\n    exportAs: [\"kendo-popup\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([AlignService, AnimationService, DOMService, PositionService, ResizeService, ScrollableService]), ɵngcc0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c1,\n    decls: 5,\n    vars: 4,\n    consts: [[1, \"k-popup\", 3, \"ngClass\"], [\"container\", \"\"], [3, \"ngTemplateOutlet\", \"ngIf\"], [3, \"rateLimit\", \"resize\"]],\n    template: function PopupComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0, 1);\n        ɵngcc0.ɵɵprojection(2);\n        ɵngcc0.ɵɵtemplate(3, PopupComponent_ng_template_3_Template, 0, 0, \"ng-template\", 2);\n        ɵngcc0.ɵɵelementStart(4, \"kendo-resize-sensor\", 3);\n        ɵngcc0.ɵɵlistener(\"resize\", function PopupComponent_Template_kendo_resize_sensor_resize_4_listener() {\n          return ctx.onResize();\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngClass\", ctx.popupClass);\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx.content)(\"ngIf\", ctx.content);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"rateLimit\", 100);\n      }\n    },\n    directives: [ɵngcc2.NgClass, ɵngcc2.NgTemplateOutlet, ɵngcc2.NgIf, ɵngcc3.ResizeSensorComponent],\n    encapsulation: 2\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], PopupComponent.prototype, \"animate\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", ElementRef)], PopupComponent.prototype, \"anchor\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], PopupComponent.prototype, \"anchorAlign\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], PopupComponent.prototype, \"collision\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], PopupComponent.prototype, \"popupAlign\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], PopupComponent.prototype, \"copyAnchorStyles\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], PopupComponent.prototype, \"popupClass\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], PopupComponent.prototype, \"positionMode\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], PopupComponent.prototype, \"offset\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], PopupComponent.prototype, \"margin\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], PopupComponent.prototype, \"anchorViewportLeave\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], PopupComponent.prototype, \"close\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], PopupComponent.prototype, \"open\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], PopupComponent.prototype, \"positionChange\", void 0);\n\n  __decorate([ViewChild('container', {\n    static: true\n  }), __metadata(\"design:type\", ElementRef)], PopupComponent.prototype, \"contentContainer\", void 0);\n\n  __decorate([ViewChild(ResizeSensorComponent, {\n    static: true\n  }), __metadata(\"design:type\", ResizeSensorComponent)], PopupComponent.prototype, \"resizeSensor\", void 0);\n\n  PopupComponent = __decorate([__metadata(\"design:paramtypes\", [ElementRef, AlignService, DOMService, PositionService, ResizeService, ScrollableService, AnimationService, Renderer2, NgZone])], PopupComponent);\n  return PopupComponent;\n})();\n\nconst removeElement = element => {\n  if (element && element.parentNode) {\n    element.parentNode.removeChild(element);\n  }\n};\n/**\n * Used to inject the Popup container. If not provided, the first root component of\n * the application is used.\n *\n * > The `POPUP_CONTAINER` can be used only with the [`PopupService`]({% slug service_popup %}) class.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Popup module\n * import { PopupModule, POPUP_CONTAINER } from '@progress/kendo-angular-popup';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { ElementRef, NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, PopupModule], // import Popup module\n *     bootstrap:    [AppComponent],\n *     providers: [{\n *       provide: POPUP_CONTAINER,\n *       useFactory: () => {\n *          //return the container ElementRef, where the popup will be injected\n *          return { nativeElement: document.body } as ElementRef;\n *       }\n *     }]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n * ```\n */\n\n\nconst POPUP_CONTAINER = new InjectionToken('Popup Container');\n/**\n * A service for opening Popup components dynamically\n * ([see example]({% slug service_popup %})).\n *\n * @export\n * @class PopupService\n */\n\nlet PopupService = /*#__PURE__*/(() => {\n  let PopupService = class PopupService {\n    constructor(applicationRef, componentFactoryResolver, injector, container) {\n      this.applicationRef = applicationRef;\n      this.componentFactoryResolver = componentFactoryResolver;\n      this.injector = injector;\n      this.container = container;\n    }\n    /**\n     * Gets the root view container into which the component will be injected.\n     *\n     * @returns {ComponentRef<any>}\n     */\n\n\n    get rootViewContainer() {\n      // https://github.com/angular/angular/blob/4.0.x/packages/core/src/application_ref.ts#L571\n      const rootComponents = this.applicationRef.components || [];\n\n      if (rootComponents[0]) {\n        return rootComponents[0];\n      }\n\n      throw new Error(`\n            View Container not found! Inject the POPUP_CONTAINER or define a specific ViewContainerRef via the appendTo option.\n            See http://www.telerik.com/kendo-angular-ui/components/popup/api/POPUP_CONTAINER/ for more details.\n        `);\n    }\n    /**\n     * Sets or gets the HTML element of the root component container.\n     *\n     * @returns {HTMLElement}\n     */\n\n\n    get rootViewContainerNode() {\n      return this.container ? this.container.nativeElement : this.getComponentRootNode(this.rootViewContainer);\n    }\n    /**\n     * Opens a Popup component. Created Popups are mounted\n     * in the DOM directly in the root application component.\n     *\n     * @param {PopupSettings} options - The options which define the Popup.\n     * @returns {ComponentRef<PopupComponent>} - A reference to the Popup object.\n     *\n     * @example\n     *\n     * ```ts-no-run\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *     <ng-template #template>\n     *      Popup content\n     *     </ng-template>\n     *     <button #anchor kendoButton (click)=\"open(anchor, template)\">Open</button>\n     *   `\n     * })\n     * export class AppComponent {\n     *     public popupRef: PopupRef;\n     *\n     *     constructor( private popupService: PopupService ) {}\n     *\n     *     public open(anchor: ElementRef, template: TemplateRef<any>): void {\n     *         if (this.popupRef) {\n     *              this.popupRef.close();\n     *              this.popupRef = null;\n     *              return;\n     *         }\n     *\n     *         this.popupRef = this.popupService.open({\n     *           anchor: anchor,\n     *           content: template\n     *         });\n     *     }\n     * }\n     * ```\n     */\n\n\n    open(options = {}) {\n      const {\n        component,\n        nodes\n      } = this.contentFrom(options.content);\n      const popupComponentRef = this.appendPopup(nodes, options.appendTo);\n      const popupInstance = popupComponentRef.instance;\n      this.projectComponentInputs(popupComponentRef, options);\n      popupComponentRef.changeDetectorRef.detectChanges();\n\n      if (component) {\n        component.changeDetectorRef.detectChanges();\n      }\n\n      const popupElement = this.getComponentRootNode(popupComponentRef);\n      return {\n        close: () => {\n          if (component) {\n            component.destroy();\n          }\n\n          popupComponentRef.destroy(); // Angular will not remove the element unless the change detection is triggered\n\n          removeElement(popupElement);\n        },\n        content: component,\n        popup: popupComponentRef,\n        popupAnchorViewportLeave: popupInstance.anchorViewportLeave,\n        popupClose: popupInstance.close,\n        popupElement: popupElement,\n        popupOpen: popupInstance.open,\n        popupPositionChange: popupInstance.positionChange\n      };\n    }\n\n    appendPopup(nodes, container) {\n      const popupComponentRef = this.createComponent(PopupComponent, nodes, container);\n\n      if (!container) {\n        this.rootViewContainerNode.appendChild(this.getComponentRootNode(popupComponentRef));\n      }\n\n      return popupComponentRef;\n    }\n    /**\n     * Gets the HTML element for a component reference.\n     *\n     * @param {ComponentRef<any>} componentRef\n     * @returns {HTMLElement}\n     */\n\n\n    getComponentRootNode(componentRef) {\n      return componentRef.location.nativeElement;\n    }\n    /**\n     * Gets the `ComponentFactory` instance by its type.\n     *\n     * @param {*} componentClass\n     * @param {*} nodes\n     * @returns {ComponentRef<any>}\n     */\n\n\n    getComponentFactory(componentClass) {\n      return this.componentFactoryResolver.resolveComponentFactory(componentClass);\n    }\n    /**\n     * Creates a component reference from a `Component` type class.\n     *\n     * @param {*} componentClass\n     * @param {*} nodes\n     * @returns {ComponentRef<any>}\n     */\n\n\n    createComponent(componentClass, nodes, container) {\n      const factory = this.getComponentFactory(componentClass);\n\n      if (container) {\n        return container.createComponent(factory, undefined, this.injector, nodes);\n      } else {\n        const component = factory.create(this.injector, nodes);\n        this.applicationRef.attachView(component.hostView);\n        return component;\n      }\n    }\n    /**\n     * Projects the inputs on the component.\n     *\n     * @param {ComponentRef<any>} component\n     * @param {*} options\n     * @returns {ComponentRef<any>}\n     */\n\n\n    projectComponentInputs(component, options) {\n      Object.getOwnPropertyNames(options).filter(prop => prop !== 'content' || options.content instanceof TemplateRef).map(prop => {\n        component.instance[prop] = options[prop];\n      });\n      return component;\n    }\n    /**\n     * Gets the component and the nodes to append from the `content` option.\n     *\n     * @param {*} content\n     * @returns {any}\n     */\n\n\n    contentFrom(content) {\n      if (!content || content instanceof TemplateRef) {\n        return {\n          component: null,\n          nodes: [[]]\n        };\n      }\n\n      const component = this.createComponent(content);\n      const nodes = component ? [component.location.nativeElement] : [];\n      return {\n        component: component,\n        nodes: [nodes // <ng-content>\n        ]\n      };\n    }\n\n  };\n\n  PopupService.ɵfac = function PopupService_Factory(t) {\n    return new (t || PopupService)(ɵngcc0.ɵɵinject(ɵngcc0.ApplicationRef), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(POPUP_CONTAINER, 8));\n  };\n\n  PopupService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: PopupService,\n    factory: function (t) {\n      return PopupService.ɵfac(t);\n    }\n  });\n  PopupService = __decorate([__param(3, Inject(POPUP_CONTAINER)), __param(3, Optional()), __metadata(\"design:paramtypes\", [ApplicationRef, ComponentFactoryResolver, Injector, ElementRef])], PopupService);\n  return PopupService;\n})();\nconst POPUP_DIRECTIVES = [PopupComponent];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Popup component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Popup module\n * import { PopupModule } from '@progress/kendo-angular-popup';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, PopupModule], // import Popup module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\nlet PopupModule = /*#__PURE__*/(() => {\n  let PopupModule = class PopupModule {};\n\n  PopupModule.ɵfac = function PopupModule_Factory(t) {\n    return new (t || PopupModule)();\n  };\n\n  PopupModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: PopupModule\n  });\n  PopupModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [PopupService],\n    imports: [[CommonModule, ResizeSensorModule]]\n  });\n  return PopupModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PopupModule, {\n    declarations: function () {\n      return [PopupComponent];\n    },\n    imports: function () {\n      return [CommonModule, ResizeSensorModule];\n    },\n    exports: function () {\n      return [PopupComponent];\n    }\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AlignService, AnimationService, DOMService, PositionService, ResizeService, ScrollableService, PopupService, POPUP_CONTAINER, PopupComponent, PopupModule, SCALE }; //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt3SUFHZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzhJQUFFO0FBQ0YsMkJBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3VKQUFFO0FBQ0YsOEJBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7aUpBQUU7QUFDRiw0QkFFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NkpBQUU7QUFDRixnQ0FFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzBKQUFFO0FBQ0YsK0JBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OytIQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFjRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzhJQUFFO0FBQ0YsMkJBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttU0FTZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogQ29weXJpZ2h0IMKpIDIwMjEgUHJvZ3Jlc3MgU29mdHdhcmUgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qIExpY2Vuc2VkIHVuZGVyIGNvbW1lcmNpYWwgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbW9yZSBpbmZvcm1hdGlvblxuKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgX19kZWNvcmF0ZSwgX19wYXJhbSwgX19tZXRhZGF0YSB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBJbmplY3QsIE9wdGlvbmFsLCBOZ1pvbmUsIEV2ZW50RW1pdHRlciwgaXNEZXZNb2RlLCBJbnB1dCwgRWxlbWVudFJlZiwgT3V0cHV0LCBWaWV3Q2hpbGQsIENvbXBvbmVudCwgUmVuZGVyZXIyLCBUZW1wbGF0ZVJlZiwgQXBwbGljYXRpb25SZWYsIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgSW5qZWN0b3IsIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBzaWJsaW5nQ29udGFpbmVyLCBwYXJlbnRzLCBhZGRTY3JvbGwsIGFsaWduLCBib3VuZGluZ09mZnNldCwgb2Zmc2V0LCBwb3NpdGlvbldpdGhTY3JvbGwsIHJlbW92ZVNjcm9sbCwgcmVzdHJpY3RUb1ZpZXcsIHNjcm9sbFBvc2l0aW9uLCBnZXRXaW5kb3dWaWV3UG9ydCB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1wb3B1cC1jb21tb24nO1xuaW1wb3J0IHsgaXNEb2N1bWVudEF2YWlsYWJsZSwgaGFzT2JzZXJ2ZXJzLCBSZXNpemVTZW5zb3JDb21wb25lbnQsIFJlc2l6ZVNlbnNvck1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWNvbW1vbic7XG5pbXBvcnQgeyBmcm9tRXZlbnQsIG1lcmdlLCBmcm9tIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBhdWRpdFRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBzdHlsZSwgYW5pbWF0ZSwgQW5pbWF0aW9uQnVpbGRlciB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgdmFsaWRhdGVQYWNrYWdlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWxpY2Vuc2luZyc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZWl0aGVyUmVjdCA9IChyZWN0LCBvZmZzZXQkJDEpID0+IHtcbiAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHsgaGVpZ2h0OiAwLCBsZWZ0OiBvZmZzZXQkJDEubGVmdCwgdG9wOiBvZmZzZXQkJDEudG9wLCB3aWR0aDogMCB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVjdDtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgcmVtb3ZlU3RhY2tpbmdPZmZzZXQgPSAocmVjdCwgc3RhY2tpbmdPZmZzZXQpID0+IHtcbiAgICBpZiAoIXN0YWNraW5nT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCAtIHN0YWNraW5nT2Zmc2V0LmxlZnQsXG4gICAgICAgIHRvcDogcmVjdC50b3AgLSBzdGFja2luZ09mZnNldC50b3AsXG4gICAgICAgIHdpZHRoOiByZWN0LndpZHRoXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc0RpZmZlcmVudE9mZnNldCA9IChvbGRPZmZzZXQsIG5ld09mZnNldCkgPT4ge1xuICAgIGNvbnN0IHsgbGVmdDogb2xkTGVmdCwgdG9wOiBvbGRUb3AgfSA9IG9sZE9mZnNldDtcbiAgICBjb25zdCB7IGxlZnQ6IG5ld0xlZnQsIHRvcDogbmV3VG9wIH0gPSBuZXdPZmZzZXQ7XG4gICAgcmV0dXJuIE1hdGguYWJzKG9sZExlZnQgLSBuZXdMZWZ0KSA+PSAxIHx8IE1hdGguYWJzKG9sZFRvcCAtIG5ld1RvcCkgPj0gMTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNXaW5kb3dBdmFpbGFibGUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBPVkVSRkxPV19SRUdFWFAgPSAvYXV0b3xzY3JvbGwvO1xuY29uc3Qgb3ZlcmZsb3dFbGVtZW50U3R5bGUgPSAoZWxlbWVudCkgPT4ge1xuICAgIHJldHVybiBgJHtlbGVtZW50LnN0eWxlLm92ZXJmbG93fSR7ZWxlbWVudC5zdHlsZS5vdmVyZmxvd1h9JHtlbGVtZW50LnN0eWxlLm92ZXJmbG93WX1gO1xufTtcbmNvbnN0IG92ZXJmbG93Q29tcHV0ZWRTdHlsZSA9IChlbGVtZW50KSA9PiB7XG4gICAgY29uc3Qgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgcmV0dXJuIGAke3N0eWxlcy5vdmVyZmxvd30ke3N0eWxlcy5vdmVyZmxvd1h9JHtzdHlsZXMub3ZlcmZsb3dZfWA7XG59O1xuY29uc3Qgb3ZlcmZsb3dTdHlsZSA9IChlbGVtZW50KSA9PiB7XG4gICAgcmV0dXJuIG92ZXJmbG93RWxlbWVudFN0eWxlKGVsZW1lbnQpIHx8IG92ZXJmbG93Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgc2Nyb2xsYWJsZVBhcmVudHMgPSAoZWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IHBhcmVudEVsZW1lbnRzID0gW107XG4gICAgaWYgKCFpc0RvY3VtZW50QXZhaWxhYmxlKCkgfHwgIWlzV2luZG93QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudEVsZW1lbnRzO1xuICAgIH1cbiAgICBsZXQgcGFyZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKE9WRVJGTE9XX1JFR0VYUC50ZXN0KG92ZXJmbG93U3R5bGUocGFyZW50KSkgfHwgcGFyZW50Lmhhc0F0dHJpYnV0ZSgnZGF0YS1zY3JvbGxhYmxlJykpIHtcbiAgICAgICAgICAgIHBhcmVudEVsZW1lbnRzLnB1c2gocGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgcGFyZW50RWxlbWVudHMucHVzaCh3aW5kb3cpO1xuICAgIHJldHVybiBwYXJlbnRFbGVtZW50cztcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgRlJBTUVfRFVSQVRJT04gPSAxMDAwIC8gNjA7IC8vMTAwMG1zIGRpdmlkZWQgYnkgNjBmcHNcbmZ1bmN0aW9uIG1lbW9pemUoZnVuKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmIChjYWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gZnVuKC4uLmFyZ3MpO1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG5jb25zdCDJtTMgPSAoKSA9PiB7XG4gICAgaWYgKCFpc0RvY3VtZW50QXZhaWxhYmxlKCkgJiYgZG9jdW1lbnQuYm9keSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHRvcCA9IDEwO1xuICAgIGNvbnN0IHBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgcGFyZW50LnN0eWxlLnRyYW5zZm9ybSA9IFwibWF0cml4KDEwLCAwLCAwLCAxMCwgMCwgMClcIjtcbiAgICBwYXJlbnQuaW5uZXJIVE1MID0gYDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogZml4ZWQ7IHRvcDogJHt0b3B9cHg7XCI+Y2hpbGQ8L2Rpdj5gO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocGFyZW50KTtcbiAgICBjb25zdCBpc0RpZmZlcmVudCA9IHBhcmVudC5jaGlsZHJlblswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgIT09IHRvcDtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHBhcmVudCk7XG4gICAgcmV0dXJuIGlzRGlmZmVyZW50O1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBoYXNSZWxhdGl2ZVN0YWNraW5nQ29udGV4dCA9IG1lbW9pemUoybUzKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCB6SW5kZXggPSAoYW5jaG9yLCBjb250YWluZXIpID0+IHtcbiAgICBpZiAoIWFuY2hvciB8fCAhaXNEb2N1bWVudEF2YWlsYWJsZSgpIHx8ICFpc1dpbmRvd0F2YWlsYWJsZSgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzaWJsaW5nID0gc2libGluZ0NvbnRhaW5lcihhbmNob3IsIGNvbnRhaW5lcik7XG4gICAgaWYgKCFzaWJsaW5nKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbYW5jaG9yXS5jb25jYXQocGFyZW50cyhhbmNob3IsIHNpYmxpbmcpKS5yZWR1Y2UoKGluZGV4LCBwKSA9PiB7XG4gICAgICAgIGNvbnN0IHpJbmRleFN0eWxlID0gcC5zdHlsZS56SW5kZXggfHwgd2luZG93LmdldENvbXB1dGVkU3R5bGUocCkuekluZGV4O1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gcGFyc2VJbnQoekluZGV4U3R5bGUsIDEwKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQgPiBpbmRleCA/IGN1cnJlbnQgOiBpbmRleDtcbiAgICB9LCAwKTtcbiAgICByZXR1cm4gcmVzdWx0ID8gKHJlc3VsdCArIDEpIDogbnVsbDtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgc2NhbGVSZWN0ID0gKHJlY3QsIHNjYWxlKSA9PiB7XG4gICAgaWYgKCFyZWN0IHx8IHNjYWxlID09PSAxKSB7XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0IC8gc2NhbGUsXG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCAvIHNjYWxlLFxuICAgICAgICB0b3A6IHJlY3QudG9wIC8gc2NhbGUsXG4gICAgICAgIHdpZHRoOiByZWN0LndpZHRoIC8gc2NhbGVcbiAgICB9O1xufTtcblxuY29uc3QgU1RZTEVTID0gW1xuICAgICdmb250LXNpemUnLFxuICAgICdmb250LWZhbWlseScsXG4gICAgJ2ZvbnQtc3RyZXRjaCcsXG4gICAgJ2ZvbnQtc3R5bGUnLFxuICAgICdmb250LXdlaWdodCcsXG4gICAgJ2xpbmUtaGVpZ2h0J1xuXTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRE9NU2VydmljZSA9IGNsYXNzIERPTVNlcnZpY2Uge1xuICAgIGFkZE9mZnNldChjdXJyZW50LCBhZGRpdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogY3VycmVudC5sZWZ0ICsgYWRkaXRpb24ubGVmdCxcbiAgICAgICAgICAgIHRvcDogY3VycmVudC50b3AgKyBhZGRpdGlvbi50b3BcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYWRkU2Nyb2xsKHJlY3QsIHNjcm9sbCkge1xuICAgICAgICByZXR1cm4gYWRkU2Nyb2xsKHJlY3QsIHNjcm9sbCk7XG4gICAgfVxuICAgIGFsaWduKHNldHRpbmdzKSB7XG4gICAgICAgIHJldHVybiBhbGlnbihzZXR0aW5ncyk7XG4gICAgfVxuICAgIGJvdW5kaW5nT2Zmc2V0KGVsKSB7XG4gICAgICAgIHJldHVybiBib3VuZGluZ09mZnNldCh0aGlzLm5hdGl2ZUVsZW1lbnQoZWwpKTtcbiAgICB9XG4gICAgZ2V0Rm9udFN0eWxlcyhlbCkge1xuICAgICAgICBjb25zdCB3aW5kb3cgPSB0aGlzLmdldFdpbmRvdygpO1xuICAgICAgICBpZiAoIXdpbmRvdyB8fCAhZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wdXRlZFN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMubmF0aXZlRWxlbWVudChlbCkpO1xuICAgICAgICByZXR1cm4gU1RZTEVTLm1hcChmb250ID0+ICh7IGtleTogZm9udCwgdmFsdWU6IGNvbXB1dGVkU3R5bGVzW2ZvbnRdIH0pKTtcbiAgICB9XG4gICAgZ2V0V2luZG93KCkge1xuICAgICAgICByZXR1cm4gaXNXaW5kb3dBdmFpbGFibGUoKSA/IHdpbmRvdyA6IG51bGw7XG4gICAgfVxuICAgIGhhc09mZnNldFBhcmVudChlbCkge1xuICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICEhdGhpcy5uYXRpdmVFbGVtZW50KGVsKS5vZmZzZXRQYXJlbnQ7XG4gICAgfVxuICAgIG9mZnNldChlbCkge1xuICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Zmc2V0KHRoaXMubmF0aXZlRWxlbWVudChlbCkpO1xuICAgIH1cbiAgICBvZmZzZXRBdFBvaW50KGVsLCBjdXJyZW50TG9jYXRpb24pIHtcbiAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMubmF0aXZlRWxlbWVudChlbCk7XG4gICAgICAgIGNvbnN0IHsgbGVmdCwgdG9wLCB0cmFuc2l0aW9uIH0gPSBlbGVtZW50LnN0eWxlO1xuICAgICAgICBlbGVtZW50LnN0eWxlLnRyYW5zaXRpb24gPSAnbm9uZSc7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUubGVmdCA9IGAke2N1cnJlbnRMb2NhdGlvbi5sZWZ0fXB4YDtcbiAgICAgICAgZWxlbWVudC5zdHlsZS50b3AgPSBgJHtjdXJyZW50TG9jYXRpb24udG9wfXB4YDtcbiAgICAgICAgY29uc3QgY3VycmVudE9mZnNldCA9IG9mZnNldChlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gbGVmdDtcbiAgICAgICAgZWxlbWVudC5zdHlsZS50b3AgPSB0b3A7XG4gICAgICAgIC8vIHByZXZlbnRzIGVsZW1lbnRzIHdpdGggdHJhbnNpdGlvbiB0byBiZSBhbmltYXRlZCBiZWNhdXNlIG9mIHRoZSBjaGFuZ2VcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXVudXNlZC1leHByZXNzaW9uXG4gICAgICAgIGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBlbGVtZW50LnN0eWxlLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuICAgICAgICByZXR1cm4gY3VycmVudE9mZnNldDtcbiAgICB9XG4gICAgbmF0aXZlRWxlbWVudChlbCkge1xuICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWwubmF0aXZlRWxlbWVudCB8fCBlbDtcbiAgICB9XG4gICAgcG9zaXRpb24oZWxlbWVudCwgcG9wdXAsIHNjYWxlID0gMSkge1xuICAgICAgICBpZiAoIWVsZW1lbnQgfHwgIXBvcHVwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zaXRpb25XaXRoU2Nyb2xsKHRoaXMubmF0aXZlRWxlbWVudChlbGVtZW50KSwgdGhpcy5uYXRpdmVFbGVtZW50KHBvcHVwKSwgc2NhbGUpO1xuICAgIH1cbiAgICByZW1vdmVTY3JvbGwocmVjdCwgc2Nyb2xsKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVTY3JvbGwocmVjdCwgc2Nyb2xsKTtcbiAgICB9XG4gICAgcmVzdHJpY3RUb1ZpZXcoc2V0dGluZ3MpIHtcbiAgICAgICAgcmV0dXJuIHJlc3RyaWN0VG9WaWV3KHNldHRpbmdzKTtcbiAgICB9XG4gICAgc2Nyb2xsUG9zaXRpb24oZWwpIHtcbiAgICAgICAgcmV0dXJuIHNjcm9sbFBvc2l0aW9uKHRoaXMubmF0aXZlRWxlbWVudChlbCkpO1xuICAgIH1cbiAgICBzY3JvbGxhYmxlUGFyZW50cyhlbCkge1xuICAgICAgICByZXR1cm4gc2Nyb2xsYWJsZVBhcmVudHModGhpcy5uYXRpdmVFbGVtZW50KGVsKSk7XG4gICAgfVxuICAgIHN0YWNraW5nRWxlbWVudE9mZnNldChlbCkge1xuICAgICAgICBjb25zdCByZWxhdGl2ZUNvbnRleHRFbGVtZW50ID0gdGhpcy5nZXRSZWxhdGl2ZUNvbnRleHRFbGVtZW50KGVsKTtcbiAgICAgICAgaWYgKCFyZWxhdGl2ZUNvbnRleHRFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Zmc2V0KHJlbGF0aXZlQ29udGV4dEVsZW1lbnQpO1xuICAgIH1cbiAgICBzdGFja2luZ0VsZW1lbnRTY3JvbGwoZWwpIHtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVDb250ZXh0RWxlbWVudCA9IHRoaXMuZ2V0UmVsYXRpdmVDb250ZXh0RWxlbWVudChlbCk7XG4gICAgICAgIGlmICghcmVsYXRpdmVDb250ZXh0RWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiByZWxhdGl2ZUNvbnRleHRFbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICAgICAgICB5OiByZWxhdGl2ZUNvbnRleHRFbGVtZW50LnNjcm9sbFRvcFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRSZWxhdGl2ZUNvbnRleHRFbGVtZW50KGVsKSB7XG4gICAgICAgIGlmICghZWwgfHwgIWhhc1JlbGF0aXZlU3RhY2tpbmdDb250ZXh0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLm5hdGl2ZUVsZW1lbnQoZWwpLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpLnRyYW5zZm9ybSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB1c2VSZWxhdGl2ZVBvc2l0aW9uKGVsKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuZ2V0UmVsYXRpdmVDb250ZXh0RWxlbWVudChlbCk7XG4gICAgfVxuICAgIHdpbmRvd1ZpZXdQb3J0KGVsKSB7XG4gICAgICAgIHJldHVybiBnZXRXaW5kb3dWaWV3UG9ydCh0aGlzLm5hdGl2ZUVsZW1lbnQoZWwpKTtcbiAgICB9XG4gICAgekluZGV4KGFuY2hvciwgY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiB6SW5kZXgodGhpcy5uYXRpdmVFbGVtZW50KGFuY2hvciksIHRoaXMubmF0aXZlRWxlbWVudChjb250YWluZXIpKTtcbiAgICB9XG4gICAgem9vbUxldmVsKCkge1xuICAgICAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSB8fCAhaXNXaW5kb3dBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCAvIHdpbmRvdy5pbm5lcldpZHRoKS50b0ZpeGVkKDIpKSB8fCAxO1xuICAgIH1cbiAgICBpc1pvb21lZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuem9vbUxldmVsKCkgPiAxO1xuICAgIH1cbn07XG5ET01TZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpXG5dLCBET01TZXJ2aWNlKTtcblxuLyoqXG4gKiBVc2VkIHRvIHNldCB0aGUgZG9jdW1lbnQgc2NhbGUgd2hlbiB1c2luZyBhIFtzY2FsZSB0cmFuc2Zvcm1dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy90cmFuc2Zvcm0tZnVuY3Rpb24vc2NhbGUpLlxuICpcbiAqIFRoZSBkb2N1bWVudCBvciBjb250YWluZXIgc2NhbGUgaXMgcmVxdWlyZWQgdG8gY29tcHV0ZSB0aGUgcG9wdXAgcG9zaXRpb24gY29ycmVjdGx5LiBEZXRlY3RpbmcgdGhlIHNjYWxlIGlzIG5vdCByZWxpYWJsZSBhbmQgbXVzdCBiZSBzZXQgYnkgcHJvdmlkaW5nIGEgdmFsdWUgZm9yIFNDQUxFLiBTZWUgW1N1cHBvcnQgZm9yIERvY3VtZW50IFNjYWxlXSh7JSBzbHVnIGRvY3VtZW50c2NhbGVfcG9wdXAgJX0pLlxuICpcbiAqID4gVXNpbmcgdGhpcyB0b2tlbiBpcyBub3QgbmVjZXNzYXJ5IGZvciB1c2VyLWFwcGxpZWQgYnJvd3NlciB6b29tLlxuICpcbiAqIHslIG1ldGEgaGVpZ2h0OjMwMCAlfVxuICogeyUgZW1iZWRfZmlsZSBzY2FsZS9hcHAuY29tcG9uZW50LnRzIHByZXZpZXcgJX1cbiAqIHslIGVtYmVkX2ZpbGUgc2hhcmVkL2FwcC5tb2R1bGUudHMgJX1cbiAqIHslIGVtYmVkX2ZpbGUgc2hhcmVkL21haW4udHMgJX1cbiAqIHslIGVuZG1ldGEgJX1cbiAqXG4gKlxuICovXG5jb25zdCBTQ0FMRSA9IG5ldyBJbmplY3Rpb25Ub2tlbignUG9wdXAgRG9jdW1lbnQgU2NhbGUnKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBBbGlnblNlcnZpY2UgPSBjbGFzcyBBbGlnblNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKF9kb20sIHNjYWxlID0gMSkge1xuICAgICAgICB0aGlzLl9kb20gPSBfZG9tO1xuICAgICAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgfVxuICAgIGFsaWduRWxlbWVudChzZXR0aW5ncykge1xuICAgICAgICBjb25zdCB7IGFuY2hvciwgZWxlbWVudCwgYW5jaG9yQWxpZ24sIGVsZW1lbnRBbGlnbiwgbWFyZ2luLCBvZmZzZXQ6IG9mZnNldCQkMSwgcG9zaXRpb25Nb2RlIH0gPSBzZXR0aW5ncztcbiAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLnNjYWxlIHx8IDE7XG4gICAgICAgIGNvbnN0IGZpeGVkTW9kZSA9IHBvc2l0aW9uTW9kZSA9PT0gJ2ZpeGVkJyB8fCAhdGhpcy5fZG9tLmhhc09mZnNldFBhcmVudChlbGVtZW50KTtcbiAgICAgICAgY29uc3QgYW5jaG9yUmVjdCA9IGZpeGVkTW9kZSA/IHRoaXMuYWJzb2x1dGVSZWN0KGFuY2hvciwgZWxlbWVudCwgb2Zmc2V0JCQxLCBzY2FsZSkgOiB0aGlzLnJlbGF0aXZlUmVjdChhbmNob3IsIGVsZW1lbnQsIG9mZnNldCQkMSwgc2NhbGUpO1xuICAgICAgICBjb25zdCBlbGVtZW50UmVjdCA9IHNjYWxlUmVjdCh0aGlzLl9kb20ub2Zmc2V0KGVsZW1lbnQpLCBzY2FsZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RvbS5hbGlnbih7XG4gICAgICAgICAgICBhbmNob3JBbGlnbjogYW5jaG9yQWxpZ24sXG4gICAgICAgICAgICBhbmNob3JSZWN0OiBhbmNob3JSZWN0LFxuICAgICAgICAgICAgZWxlbWVudEFsaWduOiBlbGVtZW50QWxpZ24sXG4gICAgICAgICAgICBlbGVtZW50UmVjdDogZWxlbWVudFJlY3QsXG4gICAgICAgICAgICBtYXJnaW5cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFic29sdXRlUmVjdChhbmNob3IsIGVsZW1lbnQsIG9mZnNldCQkMSwgc2NhbGUpIHtcbiAgICAgICAgY29uc3Qgc2Nyb2xsUG9zID0gdGhpcy5lbGVtZW50U2Nyb2xsUG9zaXRpb24oYW5jaG9yLCBlbGVtZW50KTtcbiAgICAgICAgY29uc3QgcmVjdCA9IGVpdGhlclJlY3QodGhpcy5fZG9tLm9mZnNldChhbmNob3IpLCBvZmZzZXQkJDEpO1xuICAgICAgICBjb25zdCBzdGFja1NjYWxlID0gMiAqIHNjYWxlO1xuICAgICAgICBjb25zdCBzdGFja1Njcm9sbCA9IHRoaXMuX2RvbS5zdGFja2luZ0VsZW1lbnRTY3JvbGwoZWxlbWVudCk7XG4gICAgICAgIGlmIChzY2FsZSAhPT0gMSAmJiBzdGFja1Njcm9sbCkge1xuICAgICAgICAgICAgc3RhY2tTY3JvbGwueCAvPSBzdGFja1NjYWxlO1xuICAgICAgICAgICAgc3RhY2tTY3JvbGwueSAvPSBzdGFja1NjYWxlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YWNrT2Zmc2V0ID0gdGhpcy5fZG9tLnN0YWNraW5nRWxlbWVudE9mZnNldChlbGVtZW50KTtcbiAgICAgICAgaWYgKHNjYWxlICE9PSAxICYmIHN0YWNrT2Zmc2V0KSB7XG4gICAgICAgICAgICBzdGFja09mZnNldC5sZWZ0IC89IHN0YWNrU2NhbGU7XG4gICAgICAgICAgICBzdGFja09mZnNldC50b3AgLz0gc3RhY2tTY2FsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZG9tLnJlbW92ZVNjcm9sbCh0aGlzLl9kb20uYWRkU2Nyb2xsKHJlbW92ZVN0YWNraW5nT2Zmc2V0KHNjYWxlUmVjdChyZWN0LCBzY2FsZSksIHN0YWNrT2Zmc2V0KSwgc3RhY2tTY3JvbGwpLCBzY3JvbGxQb3MpO1xuICAgIH1cbiAgICBlbGVtZW50U2Nyb2xsUG9zaXRpb24oYW5jaG9yLCBlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBhbmNob3IgPyB7IHg6IDAsIHk6IDAgfSA6IHRoaXMuX2RvbS5zY3JvbGxQb3NpdGlvbihlbGVtZW50KTtcbiAgICB9XG4gICAgcmVsYXRpdmVSZWN0KGFuY2hvciwgZWxlbWVudCwgb2Zmc2V0JCQxLCBzY2FsZSkge1xuICAgICAgICBjb25zdCByZWN0ID0gZWl0aGVyUmVjdCh0aGlzLl9kb20ucG9zaXRpb24oYW5jaG9yLCBlbGVtZW50LCBzY2FsZSksIG9mZnNldCQkMSk7XG4gICAgICAgIHJldHVybiBzY2FsZVJlY3QocmVjdCwgc2NhbGUpO1xuICAgIH1cbn07XG5BbGlnblNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19wYXJhbSgxLCBJbmplY3QoU0NBTEUpKSwgX19wYXJhbSgxLCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0RPTVNlcnZpY2UsIE51bWJlcl0pXG5dLCBBbGlnblNlcnZpY2UpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IFBvc2l0aW9uU2VydmljZSA9IGNsYXNzIFBvc2l0aW9uU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoX2RvbSwgc2NhbGUgPSAxKSB7XG4gICAgICAgIHRoaXMuX2RvbSA9IF9kb207XG4gICAgICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICB9XG4gICAgcG9zaXRpb25FbGVtZW50KHNldHRpbmdzKSB7XG4gICAgICAgIGNvbnN0IHsgYW5jaG9yLCBjdXJyZW50TG9jYXRpb24sIGVsZW1lbnQsIGFuY2hvckFsaWduLCBlbGVtZW50QWxpZ24sIGNvbGxpc2lvbnMsIG1hcmdpbiB9ID0gc2V0dGluZ3M7XG4gICAgICAgIGNvbnN0IGRvbSA9IHRoaXMuX2RvbTtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLnNjYWxlIHx8IDE7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRPZmZzZXQgPSBkb20ub2Zmc2V0QXRQb2ludChlbGVtZW50LCBjdXJyZW50TG9jYXRpb24pO1xuICAgICAgICBjb25zdCBlbGVtZW50UmVjdCA9IHNjYWxlUmVjdChlbGVtZW50T2Zmc2V0LCBzY2FsZSk7XG4gICAgICAgIGNvbnN0IGFuY2hvck9mZnNldCA9IHNjYWxlUmVjdChkb20ub2Zmc2V0KGFuY2hvciksIHNjYWxlKTtcbiAgICAgICAgY29uc3QgYW5jaG9yUmVjdCA9IGVpdGhlclJlY3QoYW5jaG9yT2Zmc2V0LCBjdXJyZW50TG9jYXRpb24pO1xuICAgICAgICBjb25zdCB2aWV3UG9ydCA9IHNldHRpbmdzLnZpZXdQb3J0IHx8IGRvbS53aW5kb3dWaWV3UG9ydChlbGVtZW50KTtcbiAgICAgICAgdmlld1BvcnQud2lkdGggPSB2aWV3UG9ydC53aWR0aCAvIHNjYWxlO1xuICAgICAgICB2aWV3UG9ydC5oZWlnaHQgPSB2aWV3UG9ydC5oZWlnaHQgLyBzY2FsZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZG9tLnJlc3RyaWN0VG9WaWV3KHtcbiAgICAgICAgICAgIGFuY2hvckFsaWduLFxuICAgICAgICAgICAgYW5jaG9yUmVjdCxcbiAgICAgICAgICAgIGNvbGxpc2lvbnMsXG4gICAgICAgICAgICBlbGVtZW50QWxpZ24sXG4gICAgICAgICAgICBlbGVtZW50UmVjdCxcbiAgICAgICAgICAgIG1hcmdpbixcbiAgICAgICAgICAgIHZpZXdQb3J0XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBvZmZzZXQkJDEgPSBkb20uYWRkT2Zmc2V0KGN1cnJlbnRMb2NhdGlvbiwgcmVzdWx0Lm9mZnNldCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmbGlwOiByZXN1bHQuZmxpcCxcbiAgICAgICAgICAgIGZsaXBwZWQ6IHJlc3VsdC5mbGlwcGVkLFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQkJDFcbiAgICAgICAgfTtcbiAgICB9XG59O1xuUG9zaXRpb25TZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fcGFyYW0oMSwgSW5qZWN0KFNDQUxFKSksIF9fcGFyYW0oMSwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtET01TZXJ2aWNlLCBOdW1iZXJdKVxuXSwgUG9zaXRpb25TZXJ2aWNlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBSZXNpemVTZXJ2aWNlID0gY2xhc3MgUmVzaXplU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoX2RvbSwgX3pvbmUpIHtcbiAgICAgICAgdGhpcy5fZG9tID0gX2RvbTtcbiAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xuICAgIH1cbiAgICBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFpc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gZnJvbUV2ZW50KHRoaXMuX2RvbS5nZXRXaW5kb3coKSwgXCJyZXNpemVcIilcbiAgICAgICAgICAgICAgICAucGlwZShhdWRpdFRpbWUoRlJBTUVfRFVSQVRJT04pKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gY2FsbGJhY2soKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIGlzVW5zdWJzY3JpYmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJzY3JpcHRpb24gJiYgdGhpcy5zdWJzY3JpcHRpb24uY2xvc2VkO1xuICAgIH1cbn07XG5SZXNpemVTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRE9NU2VydmljZSwgTmdab25lXSlcbl0sIFJlc2l6ZVNlcnZpY2UpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgVEhSRVNIT0xEX0RJRkYgPSAxO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBTY3JvbGxhYmxlU2VydmljZSA9IGNsYXNzIFNjcm9sbGFibGVTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihfZG9tLCBfem9uZSkge1xuICAgICAgICB0aGlzLl9kb20gPSBfZG9tO1xuICAgICAgICB0aGlzLl96b25lID0gX3pvbmU7XG4gICAgfVxuICAgIGZvckVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjayB8fCAhaXNEb2N1bWVudEF2YWlsYWJsZSgpIHx8ICF0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYXRpdmVFbGVtZW50ID0gdGhpcy5fZG9tLm5hdGl2ZUVsZW1lbnQodGhpcy5lbGVtZW50KTtcbiAgICAgICAgY29uc3QgcGFyZW50cyQkMSA9IHRoaXMuX2RvbS5zY3JvbGxhYmxlUGFyZW50cyh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmFibGVzID0gcGFyZW50cyQkMS5tYXAocCA9PiBmcm9tRXZlbnQocCwgXCJzY3JvbGxcIikucGlwZShhdWRpdFRpbWUoRlJBTUVfRFVSQVRJT04pKSk7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0gKGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1BhcmVudCA9IHBhcmVudHMkJDEuZmlsdGVyKHAgPT4gcCA9PT0gdGFyZ2V0KS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzRG9jdW1lbnQgPSB0YXJnZXQgPT09IGRvY3VtZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzV2luZG93ID0gdGFyZ2V0ID09PSB3aW5kb3c7XG4gICAgICAgICAgICAgICAgaWYgKGlzUGFyZW50IHx8IGlzRG9jdW1lbnQgfHwgaXNXaW5kb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5pc1Zpc2libGUobmF0aXZlRWxlbWVudCwgdGFyZ2V0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gbWVyZ2UoLi4ub2JzZXJ2YWJsZXMpLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAoIXRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgaXNWaXNpYmxlKGVsZW0sIGNvbnRhaW5lcikge1xuICAgICAgICBjb25zdCBlbGVtUmVjdCA9IHRoaXMuX2RvbS5ib3VuZGluZ09mZnNldChlbGVtKTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyUmVjdCA9IHRoaXMuX2RvbS5ib3VuZGluZ09mZnNldChjb250YWluZXIpO1xuICAgICAgICBpZiAoVEhSRVNIT0xEX0RJRkYgPCAoY29udGFpbmVyUmVjdC50b3AgLSBlbGVtUmVjdC5ib3R0b20pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFRIUkVTSE9MRF9ESUZGIDwgKGVsZW1SZWN0LnRvcCAtIGNvbnRhaW5lclJlY3QuYm90dG9tKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChUSFJFU0hPTERfRElGRiA8IChlbGVtUmVjdC5sZWZ0IC0gY29udGFpbmVyUmVjdC5yaWdodCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVEhSRVNIT0xEX0RJRkYgPCAoY29udGFpbmVyUmVjdC5sZWZ0IC0gZWxlbVJlY3QucmlnaHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcblNjcm9sbGFibGVTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRE9NU2VydmljZSwgTmdab25lXSlcbl0sIFNjcm9sbGFibGVTZXJ2aWNlKTtcblxuY29uc3QgTEVGVCA9ICdsZWZ0JztcbmNvbnN0IFJJR0hUID0gJ3JpZ2h0JztcbmNvbnN0IERPV04gPSAnZG93bic7XG5jb25zdCBVUCA9ICd1cCc7XG5jb25zdCBERUZBVUxUX1RZUEUgPSAnc2xpZGUnO1xuY29uc3QgREVGQVVMVF9EVVJBVElPTiA9IDEwMDtcbmNvbnN0IGFuaW1hdGlvblR5cGVzID0ge307XG4vKiB0c2xpbnQ6ZGlzYWJsZTpvYmplY3QtbGl0ZXJhbC1zb3J0LWtleXMgKi9cbmFuaW1hdGlvblR5cGVzLmV4cGFuZCA9IChkaXJlY3Rpb24pID0+IHtcbiAgICBjb25zdCBzY2FsZSA9IGRpcmVjdGlvbiA9PT0gVVAgfHwgZGlyZWN0aW9uID09PSBET1dOID8gJ3NjYWxlWScgOiAnc2NhbGVYJztcbiAgICBjb25zdCBzdGFydFNjYWxlID0gMDtcbiAgICBjb25zdCBlbmRTY2FsZSA9IDE7XG4gICAgbGV0IG9yaWdpbjtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBET1dOKSB7XG4gICAgICAgIG9yaWdpbiA9ICd0b3AnO1xuICAgIH1cbiAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT09IExFRlQpIHtcbiAgICAgICAgb3JpZ2luID0gUklHSFQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gUklHSFQpIHtcbiAgICAgICAgb3JpZ2luID0gTEVGVDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9yaWdpbiA9ICdib3R0b20nO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogeyB0cmFuc2Zvcm06IGAke3NjYWxlfSgke3N0YXJ0U2NhbGV9KWAsIHRyYW5zZm9ybU9yaWdpbjogb3JpZ2luIH0sXG4gICAgICAgIGVuZDogeyB0cmFuc2Zvcm06IGAke3NjYWxlfSgke2VuZFNjYWxlfSlgIH1cbiAgICB9O1xufTtcbmFuaW1hdGlvblR5cGVzLnNsaWRlID0gKGRpcmVjdGlvbikgPT4ge1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IGRpcmVjdGlvbiA9PT0gTEVGVCB8fCBkaXJlY3Rpb24gPT09IFJJR0hUID8gJ3RyYW5zbGF0ZVgnIDogJ3RyYW5zbGF0ZVknO1xuICAgIGNvbnN0IHN0YXJ0ID0gZGlyZWN0aW9uID09PSBSSUdIVCB8fCBkaXJlY3Rpb24gPT09IERPV04gPyAtMTAwIDogMTAwO1xuICAgIGNvbnN0IGVuZCA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHsgdHJhbnNmb3JtOiBgJHt0cmFuc2xhdGV9KCR7c3RhcnR9JSlgIH0sXG4gICAgICAgIGVuZDogeyB0cmFuc2Zvcm06IGAke3RyYW5zbGF0ZX0oJHtlbmR9JSlgIH1cbiAgICB9O1xufTtcbmFuaW1hdGlvblR5cGVzLmZhZGUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHsgb3BhY2l0eTogMCB9LFxuICAgICAgICBlbmQ6IHsgb3BhY2l0eTogMSB9XG4gICAgfTtcbn07XG5hbmltYXRpb25UeXBlcy56b29tID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0YXJ0ID0gMDtcbiAgICBjb25zdCBlbmQgPSAxO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiB7IHRyYW5zZm9ybTogYHNjYWxlKCR7c3RhcnR9KWAgfSxcbiAgICAgICAgZW5kOiB7IHRyYW5zZm9ybTogYHNjYWxlKCR7ZW5kfSlgIH1cbiAgICB9O1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgQW5pbWF0aW9uU2VydmljZSA9IGNsYXNzIEFuaW1hdGlvblNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGFuaW1hdGlvbkJ1aWxkZXIpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25CdWlsZGVyID0gYW5pbWF0aW9uQnVpbGRlcjtcbiAgICAgICAgdGhpcy5zdGFydCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5lbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIHBsYXkoZWxlbWVudCwgb3B0aW9ucywgZmxpcCkge1xuICAgICAgICBpZiAoIXRoaXMuZmxpcCB8fCB0aGlzLmZsaXAuaG9yaXpvbnRhbCAhPT0gZmxpcC5ob3Jpem9udGFsIHx8XG4gICAgICAgICAgICB0aGlzLmZsaXAudmVydGljYWwgIT09IGZsaXAudmVydGljYWwpIHtcbiAgICAgICAgICAgIHRoaXMuZmxpcCA9IGZsaXA7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gb3B0aW9ucy50eXBlIHx8IERFRkFVTFRfVFlQRTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlc0ZuID0gYW5pbWF0aW9uVHlwZXNbdHlwZV07XG4gICAgICAgICAgICBpZiAoc3RhdGVzRm4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmdldERpcmVjdGlvbihmbGlwLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZXMgPSBzdGF0ZXNGbihkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMucGxheVN0YXRlcyhlbGVtZW50LCBzdGF0ZXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGFuaW1hdGlvbiB0eXBlOiBcIiR7dHlwZX1cIi4gVGhlIHN1cHBvcnRlZCB0eXBlcyBhcmUgc2xpZGUsIGV4cGFuZCwgZmFkZSBhbmQgem9vbS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdG9wUGxheWVyKCk7XG4gICAgfVxuICAgIHBsYXlTdGF0ZXMoZWxlbWVudCwgc3RhdGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3RvcFBsYXllcigpO1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gfHwgREVGQVVMVF9EVVJBVElPTjtcbiAgICAgICAgY29uc3QgZmFjdG9yeSA9IHRoaXMuYW5pbWF0aW9uQnVpbGRlci5idWlsZChbXG4gICAgICAgICAgICBzdHlsZShzdGF0ZXMuc3RhcnQpLFxuICAgICAgICAgICAgYW5pbWF0ZShgJHtkdXJhdGlvbn1tcyBlYXNlLWluYCwgc3R5bGUoc3RhdGVzLmVuZCkpXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBwbGF5ZXIgPSB0aGlzLnBsYXllciA9IGZhY3RvcnkuY3JlYXRlKGVsZW1lbnQpO1xuICAgICAgICBwbGF5ZXIub25Eb25lKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW5kLmVtaXQoKTtcbiAgICAgICAgICAgIHRoaXMuc3RvcFBsYXllcigpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdGFydC5lbWl0KCk7XG4gICAgICAgIHBsYXllci5wbGF5KCk7XG4gICAgfVxuICAgIGdldERpcmVjdGlvbihmbGlwLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBkaXJlY3Rpb24gPSBvcHRpb25zLmRpcmVjdGlvbiB8fCBET1dOO1xuICAgICAgICBpZiAoZmxpcC5ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBMRUZUKSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gUklHSFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFJJR0hUKSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gTEVGVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxpcC52ZXJ0aWNhbCkge1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gRE9XTikge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9IFVQO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSBVUCkge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9IERPV047XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgICB9XG4gICAgc3RvcFBsYXllcigpIHtcbiAgICAgICAgaWYgKHRoaXMucGxheWVyKSB7XG4gICAgICAgICAgICB0aGlzLnBsYXllci5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnBsYXllciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59O1xuQW5pbWF0aW9uU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0FuaW1hdGlvbkJ1aWxkZXJdKVxuXSwgQW5pbWF0aW9uU2VydmljZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBwYWNrYWdlTWV0YWRhdGEgPSB7XG4gICAgbmFtZTogJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLXBvcHVwJyxcbiAgICBwcm9kdWN0TmFtZTogJ0tlbmRvIFVJIGZvciBBbmd1bGFyJyxcbiAgICBwcm9kdWN0Q29kZXM6IFsnS0VORE9VSUFOR1VMQVInLCAnS0VORE9VSUNPTVBMRVRFJ10sXG4gICAgcHVibGlzaERhdGU6IDE2MzU5MzkzNzgsXG4gICAgdmVyc2lvbjogJycsXG4gICAgbGljZW5zaW5nRG9jc1VybDogJ2h0dHBzOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvbXktbGljZW5zZS8/dXRtX21lZGl1bT1wcm9kdWN0JnV0bV9zb3VyY2U9a2VuZG9hbmd1bGFyJnV0bV9jYW1wYWlnbj1rZW5kby11aS1hbmd1bGFyLXB1cmNoYXNlLWxpY2Vuc2Uta2V5cy13YXJuaW5nJ1xufTtcblxuY29uc3QgREVGQVVMVF9PRkZTRVQgPSB7IGxlZnQ6IC0xMDAwMCwgdG9wOiAwIH07XG5jb25zdCBBTklNQVRJT05fQ09OVEFJTkVSID0gJ2stYW5pbWF0aW9uLWNvbnRhaW5lcic7XG5jb25zdCBBTklNQVRJT05fQ09OVEFJTkVSX0ZJWEVEID0gJ2stYW5pbWF0aW9uLWNvbnRhaW5lci1maXhlZCc7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBQb3B1cCBjb21wb25lbnQgZm9yIEFuZ3VsYXJdKHslIHNsdWcgb3ZlcnZpZXdfcG9wdXAgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogX0BDb21wb25lbnQoe1xuICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICogdGVtcGxhdGU6IGBcbiAqICA8YnV0dG9uICNhbmNob3IgKGNsaWNrKT1cInNob3c9IXNob3dcIj5Ub2dnbGU8L2J1dHRvbj5cbiAqICA8a2VuZG8tcG9wdXAgKm5nSWY9XCJzaG93XCIgW2FuY2hvcl09XCJhbmNob3JcIj5cbiAqICAgICAgPHN0cm9uZz5Qb3B1cCBjb250ZW50ITwvc3Ryb25nPlxuICogIDwva2VuZG8tcG9wdXA+XG4gKiBgXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgcHVibGljIHNob3c6IGJvb2xlYW4gPSBmYWxzZTtcbiAqIH1cbiAqIGBgYFxuICovXG5sZXQgUG9wdXBDb21wb25lbnQgPSBjbGFzcyBQb3B1cENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyLCBfYWxpZ25TZXJ2aWNlLCBkb21TZXJ2aWNlLCBfcG9zaXRpb25TZXJ2aWNlLCBfcmVzaXplU2VydmljZSwgX3Njcm9sbGFibGVTZXJ2aWNlLCBhbmltYXRpb25TZXJ2aWNlLCBfcmVuZGVyZXIsIF96b25lKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLl9hbGlnblNlcnZpY2UgPSBfYWxpZ25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmRvbVNlcnZpY2UgPSBkb21TZXJ2aWNlO1xuICAgICAgICB0aGlzLl9wb3NpdGlvblNlcnZpY2UgPSBfcG9zaXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLl9yZXNpemVTZXJ2aWNlID0gX3Jlc2l6ZVNlcnZpY2U7XG4gICAgICAgIHRoaXMuX3Njcm9sbGFibGVTZXJ2aWNlID0gX3Njcm9sbGFibGVTZXJ2aWNlO1xuICAgICAgICB0aGlzLmFuaW1hdGlvblNlcnZpY2UgPSBhbmltYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29udHJvbHMgdGhlIFBvcHVwIGFuaW1hdGlvbi4gQnkgZGVmYXVsdCwgdGhlIG9wZW5pbmcgYW5kIGNsb3NpbmcgYW5pbWF0aW9uc1xuICAgICAgICAgKiBhcmUgZW5hYmxlZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGFuaW1hdGlvbnNfcG9wdXAgJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW5pbWF0ZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIGFuY2hvciBwaXZvdCBwb2ludFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGFsaWdubWVudHBvc2l0aW9uaW5nX3BvcHVwICV9I3RvYy1wb3NpdGlvbmluZykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmNob3JBbGlnbiA9IHsgaG9yaXpvbnRhbDogJ2xlZnQnLCB2ZXJ0aWNhbDogJ2JvdHRvbScgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbmZpZ3VyZXMgdGhlIGNvbGxpc2lvbiBiZWhhdmlvciBvZiB0aGUgUG9wdXBcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyB2aWV3cG9ydGJvdW5kYXJ5ZGV0ZWN0aW9uX3BvcHVwICV9KSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbGxpc2lvbiA9IHsgaG9yaXpvbnRhbDogJ2ZpdCcsIHZlcnRpY2FsOiAnZmxpcCcgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgcGl2b3QgcG9pbnQgb2YgdGhlIFBvcHVwXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgYWxpZ25tZW50cG9zaXRpb25pbmdfcG9wdXAgJX0jdG9jLXBvc2l0aW9uaW5nKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvcHVwQWxpZ24gPSB7IGhvcml6b250YWw6ICdsZWZ0JywgdmVydGljYWw6ICd0b3AnIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250cm9scyB3aGV0aGVyIHRoZSBjb21wb25lbnQgd2lsbCBjb3B5IHRoZSBgYW5jaG9yYCBmb250IHN0eWxlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29weUFuY2hvclN0eWxlcyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBwb3NpdGlvbiBtb2RlIG9mIHRoZSBjb21wb25lbnQuIEJ5IGRlZmF1bHQsIHRoZSBQb3B1cCB1c2VzIGZpeGVkIHBvc2l0aW9uaW5nLlxuICAgICAgICAgKiBUbyBtYWtlIHRoZSBQb3B1cCBhY3F1aXJlIGFic29sdXRlIHBvc2l0aW9uaW5nLCBzZXQgdGhpcyBvcHRpb24gdG8gYGFic29sdXRlYC5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBJZiB5b3UgbmVlZCB0byBzdXBwb3J0IG1vYmlsZSBicm93c2VycyB3aXRoIHRoZSB6b29tIG9wdGlvbixcbiAgICAgICAgICogdXNlIHRoZSBgYWJzb2x1dGVgIHBvc2l0aW9uaW5nIG9mIHRoZSBQb3B1cC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgaHRtbFxuICAgICAgICAgKiA8c3R5bGU+XG4gICAgICAgICAqICAucGFyZW50LWNvbnRlbnQge1xuICAgICAgICAgKiAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICAgKiAgICAgd2lkdGg6IDIwMHB4O1xuICAgICAgICAgKiAgICAgaGVpZ2h0OiAyMDBweDtcbiAgICAgICAgICogICAgIG92ZXJmbG93OiBhdXRvO1xuICAgICAgICAgKiAgICAgbWFyZ2luOiAyMDBweCBhdXRvO1xuICAgICAgICAgKiAgICAgYm9yZGVyOiAxcHggc29saWQgcmVkO1xuICAgICAgICAgKiAgfVxuICAgICAgICAgKiAgLmNvbnRlbnQge1xuICAgICAgICAgKiAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICAgKiAgICAgd2lkdGg6IDEwMHB4O1xuICAgICAgICAgKiAgICAgaGVpZ2h0OiAxMDBweDtcbiAgICAgICAgICogICAgIG92ZXJmbG93OiBhdXRvO1xuICAgICAgICAgKiAgICAgbWFyZ2luOiAzMDBweDtcbiAgICAgICAgICogICAgIGJvcmRlcjogMXB4IHNvbGlkIGJsdWU7XG4gICAgICAgICAqICB9XG4gICAgICAgICAqICAuYW5jaG9yIHtcbiAgICAgICAgICogICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICogICAgIHRvcDogMjAwcHg7XG4gICAgICAgICAqICAgICBsZWZ0OiAyMDBweDtcbiAgICAgICAgICogIH1cbiAgICAgICAgICogPC9zdHlsZT5cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAgICAgKiAgIDxkaXYgY2xhc3M9XCJleGFtcGxlLWNvbmZpZ1wiPlxuICAgICAgICAgKiAgICAgIFBvc2l0aW9uIG1vZGU6XG4gICAgICAgICAqICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwicmFkaW9cIiB2YWx1ZT1cImZpeGVkXCIgWyhuZ01vZGVsKV09XCJtb2RlXCIgLz4gRml4ZWQ8L2xhYmVsPlxuICAgICAgICAgKiAgICAgIDxsYWJlbD48aW5wdXQgdHlwZT1cInJhZGlvXCIgdmFsdWU9XCJhYnNvbHV0ZVwiIFsobmdNb2RlbCldPVwibW9kZVwiIC8+IEFic29sdXRlPC9sYWJlbD5cbiAgICAgICAgICogICA8L2Rpdj5cbiAgICAgICAgICogICA8ZGl2IGNsYXNzPVwiZXhhbXBsZS1jb25maWdcIj5cbiAgICAgICAgICogICAgICAgQXBwZW5kIHRvXG4gICAgICAgICAqICAgICAgIDxsYWJlbD5cbiAgICAgICAgICogICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiBuYW1lPVwicGxhY2VcIiBbdmFsdWVdPVwiMVwiIFsobmdNb2RlbCldPVwiY2hlY2tlZFwiIC8+XG4gICAgICAgICAqICAgICAgICAgICBSb290IGNvbXBvbmVudFxuICAgICAgICAgKiAgICAgICA8L2xhYmVsPlxuICAgICAgICAgKiAgICAgICA8bGFiZWw+XG4gICAgICAgICAqICAgICAgICAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cInBsYWNlXCIgW3ZhbHVlXT1cIjJcIiBbKG5nTW9kZWwpXT1cImNoZWNrZWRcIiAvPlxuICAgICAgICAgKiAgICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogcmVkXCI+UmVkIENvbnRhaW5lcjwvc3Bhbj5cbiAgICAgICAgICogICAgICAgPC9sYWJlbD5cbiAgICAgICAgICogICAgICAgPGxhYmVsPlxuICAgICAgICAgKiAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJwbGFjZVwiIFt2YWx1ZV09XCIzXCIgWyhuZ01vZGVsKV09XCJjaGVja2VkXCIgLz5cbiAgICAgICAgICogICAgICAgICAgIDxzcGFuIHN0eWxlPVwiY29sb3I6IGJsdWVcIj5CbHVlIENvbnRhaW5lcjwvc3Bhbj5cbiAgICAgICAgICogICAgICAgPC9sYWJlbD5cbiAgICAgICAgICogICA8L2Rpdj5cbiAgICAgICAgICogICA8ZGl2IGNsYXNzPVwiZXhhbXBsZVwiPlxuICAgICAgICAgKiAgICAgPGRpdiBjbGFzcz1cInBhcmVudC1jb250ZW50XCIgW3Njcm9sbExlZnRdPVwiMjUwXCIgW3Njcm9sbFRvcF09XCIyMzBcIj5cbiAgICAgICAgICogICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGVudFwiIFtzY3JvbGxMZWZ0XT1cIjE3MFwiIFtzY3JvbGxUb3BdPVwiMTY1XCI+XG4gICAgICAgICAqICAgICAgICAgICA8YnV0dG9uICNhbmNob3IgY2xhc3M9XCJhbmNob3JcIiAoY2xpY2spPVwic2hvdyA9ICFzaG93XCI+VG9nZ2xlPC9idXR0b24+XG4gICAgICAgICAqICAgICAgICAgICA8a2VuZG8tcG9wdXAgW3Bvc2l0aW9uTW9kZV09XCJtb2RlXCIgW2FuY2hvcl09XCJhbmNob3JcIiAoYW5jaG9yVmlld3BvcnRMZWF2ZSk9XCJzaG93PWZhbHNlXCIgKm5nSWY9XCJzaG93ICYmIGNoZWNrZWQgPT09IDNcIj5cbiAgICAgICAgICogICAgICAgICAgICAgPHVsPlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgPGxpPkl0ZW0xPC9saT5cbiAgICAgICAgICogICAgICAgICAgICAgICAgIDxsaT5JdGVtMjwvbGk+XG4gICAgICAgICAqICAgICAgICAgICAgICAgICA8bGk+SXRlbTM8L2xpPlxuICAgICAgICAgKiAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgKiAgICAgICAgICAgPC9rZW5kby1wb3B1cD5cbiAgICAgICAgICogICAgICAgICAgIDxzcGFuIHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB0b3A6IDQwMHB4OyBsZWZ0OiA0MDBweFwiPkJvdHRvbS9SaWdodDwvc3Bhbj5cbiAgICAgICAgICogICAgICAgICA8L2Rpdj5cbiAgICAgICAgICogICAgICAgICA8a2VuZG8tcG9wdXAgW3Bvc2l0aW9uTW9kZV09XCJtb2RlXCIgW2FuY2hvcl09XCJhbmNob3JcIiAoYW5jaG9yVmlld3BvcnRMZWF2ZSk9XCJzaG93PWZhbHNlXCIgKm5nSWY9XCJzaG93ICYmIGNoZWNrZWQgPT09IDJcIj5cbiAgICAgICAgICogICAgICAgICAgIDx1bD5cbiAgICAgICAgICogICAgICAgICAgICAgICA8bGk+SXRlbTE8L2xpPlxuICAgICAgICAgKiAgICAgICAgICAgICAgIDxsaT5JdGVtMjwvbGk+XG4gICAgICAgICAqICAgICAgICAgICAgICAgPGxpPkl0ZW0zPC9saT5cbiAgICAgICAgICogICAgICAgICAgIDwvdWw+XG4gICAgICAgICAqICAgICAgICAgPC9rZW5kby1wb3B1cD5cbiAgICAgICAgICogICAgICAgICA8c3BhbiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiA2MDBweDsgbGVmdDogNjAwcHhcIj5Cb3R0b20vUmlnaHQ8L3NwYW4+XG4gICAgICAgICAqICAgICA8L2Rpdj5cbiAgICAgICAgICogICAgIDxrZW5kby1wb3B1cCBbcG9zaXRpb25Nb2RlXT1cIm1vZGVcIiBbYW5jaG9yXT1cImFuY2hvclwiIChhbmNob3JWaWV3cG9ydExlYXZlKT1cInNob3c9ZmFsc2VcIiAqbmdJZj1cInNob3cgJiYgY2hlY2tlZCA9PT0gMVwiPlxuICAgICAgICAgKiAgICAgICA8dWw+XG4gICAgICAgICAqICAgICAgICAgICA8bGk+SXRlbTE8L2xpPlxuICAgICAgICAgKiAgICAgICAgICAgPGxpPkl0ZW0yPC9saT5cbiAgICAgICAgICogICAgICAgICAgIDxsaT5JdGVtMzwvbGk+XG4gICAgICAgICAqICAgICAgIDwvdWw+XG4gICAgICAgICAqICAgICA8L2tlbmRvLXBvcHVwPlxuICAgICAgICAgKiAgIDwvZGl2PlxuICAgICAgICAgKiBgXG4gICAgICAgICAqIH0pXG4gICAgICAgICAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICAgICAqICAgcHVibGljIGNoZWNrZWQ6IG51bWJlciA9IDM7XG4gICAgICAgICAqICAgcHVibGljIG1vZGU6IHN0cmluZyA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAqICAgcHVibGljIHNob3c6IGJvb2xlYW4gPSB0cnVlO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3NpdGlvbk1vZGUgPSAnZml4ZWQnO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGFsaWdubWVudHBvc2l0aW9uaW5nX3BvcHVwICV9I3RvYy1hbGlnbmluZy10by1hYnNvbHV0ZS1wb2ludHMpKS5cbiAgICAgICAgICogVGhlIFBvcHVwIG9wZW5zIG5leHQgdG8gdGhhdCBwb2ludC4gVGhlIFBvcHVwIHBpdm90IHBvaW50IGlzIGRlZmluZWQgYnkgdGhlIGBwb3B1cEFsaWduYCBjb25maWd1cmF0aW9uIG9wdGlvbi5cbiAgICAgICAgICogVGhlIGJvdW5kYXJ5IGRldGVjdGlvbiBpcyBhcHBsaWVkIGJ5IHVzaW5nIHRoZSB3aW5kb3cgdmlld3BvcnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9mZnNldCA9IERFRkFVTFRfT0ZGU0VUO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgYW5jaG9yIGlzIHNjcm9sbGVkIG91dHNpZGUgdGhlIHNjcmVlbiBib3VuZGFyaWVzLlxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGNsb3NpbmdfcG9wdXAgJX0jdG9jLWFmdGVyLWxlYXZpbmctdGhlLXZpZXdwb3J0KSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuY2hvclZpZXdwb3J0TGVhdmUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBhZnRlciB0aGUgY29tcG9uZW50IGlzIGNsb3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBhZnRlciB0aGUgY29tcG9uZW50IGlzIG9wZW5lZCBhbmQgdGhlIG9wZW5pbmcgYW5pbWF0aW9uIGVuZHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wZW4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBhZnRlciB0aGUgY29tcG9uZW50IGlzIG9wZW5lZCBhbmQgdGhlIFBvcHVwIGlzIHBvc2l0aW9uZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvc2l0aW9uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnJlc29sdmVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgdGhpcy5pbml0aWFsQ2hlY2sgPSB0cnVlO1xuICAgICAgICB2YWxpZGF0ZVBhY2thZ2UocGFja2FnZU1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3MoY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQsIEFOSU1BVElPTl9DT05UQUlORVIpO1xuICAgICAgICB0aGlzLnVwZGF0ZUZpeGVkQ2xhc3MoKTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMucmVwb3NpdGlvbiA9IHRoaXMucmVwb3NpdGlvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9yZXNpemVTZXJ2aWNlLnN1YnNjcmliZSh0aGlzLnJlcG9zaXRpb24pO1xuICAgICAgICB0aGlzLmFuaW1hdGlvblN1YnNjcmlwdGlvbnMgPSB0aGlzLmFuaW1hdGlvblNlcnZpY2Uuc3RhcnQuc3Vic2NyaWJlKHRoaXMub25BbmltYXRpb25TdGFydC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdWJzY3JpcHRpb25zLmFkZCh0aGlzLmFuaW1hdGlvblNlcnZpY2UuZW5kLnN1YnNjcmliZSh0aGlzLm9uQW5pbWF0aW9uRW5kLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsYWJsZVNlcnZpY2UuZm9yRWxlbWVudCh0aGlzLmFuY2hvciB8fCB0aGlzLmNvbnRhaW5lcikuc3Vic2NyaWJlKHRoaXMub25TY3JvbGwuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuY3VycmVudE9mZnNldCA9IERFRkFVTFRfT0ZGU0VUO1xuICAgICAgICB0aGlzLnNldFpJbmRleCgpO1xuICAgICAgICB0aGlzLmNvcHlGb250U3R5bGVzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRml4ZWRDbGFzcygpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmNvcHlBbmNob3JTdHlsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY29weUZvbnRTdHlsZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy5wb3NpdGlvbk1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRml4ZWRDbGFzcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5yZXBvc2l0aW9uKCk7XG4gICAgICAgIGlmICghdGhpcy5hbmltYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkUHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQW5pbWF0aW9uRW5kKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxDaGVjaykge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsQ2hlY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIC8vIHdvcmthcm91bmRzIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzE5MDk0XG4gICAgICAgICAgICAvLyB1c2VzIHByb21pc2UgYmVjYXVzZSBpdCBpcyBleGVjdXRlZCBzeW5jaHJvbm91c2x5IGFmdGVyIHRoZSBjb250ZW50IGlzIHVwZGF0ZWRcbiAgICAgICAgICAgIC8vIGRvZXMgbm90IHVzZSBvblN0YWJsZSBpbiBjYXNlIHRoZSBjdXJyZW50IHpvbmUgaXMgbm90IHRoZSBhbmd1bGFyIG9uZS5cbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmVSZXBvc2l0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnJlcG9zaXRpb25TdWJzY3JpcHRpb24gPSBmcm9tKHRoaXMucmVzb2x2ZWRQcm9taXNlKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5yZXBvc2l0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmFuY2hvclZpZXdwb3J0TGVhdmUuY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkNoYW5nZS5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLmNsb3NlLmVtaXQoKTtcbiAgICAgICAgdGhpcy5jbG9zZS5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLl9yZXNpemVTZXJ2aWNlLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuX3Njcm9sbGFibGVTZXJ2aWNlLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlUmVwb3NpdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25SZXNpemUoKSB7XG4gICAgICAgIHRoaXMucmVwb3NpdGlvbigpO1xuICAgIH1cbiAgICBvbkFuaW1hdGlvblN0YXJ0KCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50LCAnay1hbmltYXRpb24tY29udGFpbmVyLXNob3duJyk7XG4gICAgfVxuICAgIG9uQW5pbWF0aW9uRW5kKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50LCAnay1hbmltYXRpb24tY29udGFpbmVyLXNob3duJyk7XG4gICAgICAgIHRoaXMub3Blbi5lbWl0KCk7XG4gICAgICAgIHRoaXMub3Blbi5jb21wbGV0ZSgpO1xuICAgIH1cbiAgICBnZXQgY3VycmVudE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRPZmZzZXQ7XG4gICAgfVxuICAgIHNldCBjdXJyZW50T2Zmc2V0KG9mZnNldCQkMSkge1xuICAgICAgICB0aGlzLnNldENvbnRhaW5lclN0eWxlKCdsZWZ0JywgYCR7b2Zmc2V0JCQxLmxlZnR9cHhgKTtcbiAgICAgICAgdGhpcy5zZXRDb250YWluZXJTdHlsZSgndG9wJywgYCR7b2Zmc2V0JCQxLnRvcH1weGApO1xuICAgICAgICB0aGlzLl9jdXJyZW50T2Zmc2V0ID0gb2Zmc2V0JCQxO1xuICAgIH1cbiAgICBzZXRaSW5kZXgoKSB7XG4gICAgICAgIGlmICh0aGlzLmFuY2hvcikge1xuICAgICAgICAgICAgdGhpcy5zZXRDb250YWluZXJTdHlsZSgnei1pbmRleCcsIFN0cmluZyh0aGlzLmRvbVNlcnZpY2UuekluZGV4KHRoaXMuYW5jaG9yLCB0aGlzLmNvbnRhaW5lcikpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBvc2l0aW9uKCkge1xuICAgICAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZmxpcCwgb2Zmc2V0OiBvZmZzZXQkJDEgfSA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRPZmZzZXQgfHwgaXNEaWZmZXJlbnRPZmZzZXQodGhpcy5jdXJyZW50T2Zmc2V0LCBvZmZzZXQkJDEpKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRPZmZzZXQgPSBvZmZzZXQkJDE7XG4gICAgICAgICAgICBpZiAoaGFzT2JzZXJ2ZXJzKHRoaXMucG9zaXRpb25DaGFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fem9uZS5ydW4oKCkgPT4gdGhpcy5wb3NpdGlvbkNoYW5nZS5lbWl0KHsgb2Zmc2V0OiBvZmZzZXQkJDEsIGZsaXAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGUpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uU2VydmljZS5wbGF5KHRoaXMuY29udGVudENvbnRhaW5lci5uYXRpdmVFbGVtZW50LCB0aGlzLmFuaW1hdGUsIGZsaXApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzaXplU2Vuc29yLmFjY2VwdFNpemUoKTtcbiAgICB9XG4gICAgcG9zaXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGFsaWduZWRPZmZzZXQgPSB0aGlzLl9hbGlnblNlcnZpY2UuYWxpZ25FbGVtZW50KHtcbiAgICAgICAgICAgIGFuY2hvcjogdGhpcy5hbmNob3IsXG4gICAgICAgICAgICBhbmNob3JBbGlnbjogdGhpcy5hbmNob3JBbGlnbixcbiAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuY29udGFpbmVyLFxuICAgICAgICAgICAgZWxlbWVudEFsaWduOiB0aGlzLnBvcHVwQWxpZ24sXG4gICAgICAgICAgICBtYXJnaW46IHRoaXMubWFyZ2luLFxuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgIHBvc2l0aW9uTW9kZTogdGhpcy5wb3NpdGlvbk1vZGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvblNlcnZpY2UucG9zaXRpb25FbGVtZW50KHtcbiAgICAgICAgICAgIGFuY2hvcjogdGhpcy5hbmNob3IsXG4gICAgICAgICAgICBhbmNob3JBbGlnbjogdGhpcy5hbmNob3JBbGlnbixcbiAgICAgICAgICAgIGNvbGxpc2lvbnM6IHRoaXMuY29sbGlzaW9uLFxuICAgICAgICAgICAgY3VycmVudExvY2F0aW9uOiBhbGlnbmVkT2Zmc2V0LFxuICAgICAgICAgICAgZWxlbWVudDogdGhpcy5jb250YWluZXIsXG4gICAgICAgICAgICBlbGVtZW50QWxpZ246IHRoaXMucG9wdXBBbGlnbixcbiAgICAgICAgICAgIG1hcmdpbjogdGhpcy5tYXJnaW5cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uU2Nyb2xsKGlzSW5WaWV3UG9ydCkge1xuICAgICAgICBjb25zdCBoYXNMZWF2ZU9ic2VydmVycyA9IGhhc09ic2VydmVycyh0aGlzLmFuY2hvclZpZXdwb3J0TGVhdmUpO1xuICAgICAgICBpZiAoaXNJblZpZXdQb3J0IHx8ICFoYXNMZWF2ZU9ic2VydmVycykge1xuICAgICAgICAgICAgdGhpcy5yZXBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzTGVhdmVPYnNlcnZlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFuY2hvclZpZXdwb3J0TGVhdmUuZW1pdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29weUZvbnRTdHlsZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5hbmNob3IgfHwgIXRoaXMuY29weUFuY2hvclN0eWxlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9tU2VydmljZS5nZXRGb250U3R5bGVzKHRoaXMuYW5jaG9yKVxuICAgICAgICAgICAgLmZvckVhY2gocyA9PiB0aGlzLnNldENvbnRhaW5lclN0eWxlKHMua2V5LCBzLnZhbHVlKSk7XG4gICAgfVxuICAgIHVwZGF0ZUZpeGVkQ2xhc3MoKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMucG9zaXRpb25Nb2RlID09PSAnZml4ZWQnID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyc7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyW2FjdGlvbl0odGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudCwgQU5JTUFUSU9OX0NPTlRBSU5FUl9GSVhFRCk7XG4gICAgfVxuICAgIHNldENvbnRhaW5lclN0eWxlKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKHRoaXMuY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmVSZXBvc2l0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5yZXBvc2l0aW9uU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9zaXRpb25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcbl0sIFBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmNob3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmNob3JBbGlnblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcImNvbGxpc2lvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcInBvcHVwQWxpZ25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29weUFuY2hvclN0eWxlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcInBvcHVwQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwb3NpdGlvbk1vZGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvZmZzZXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXJnaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5jaG9yVmlld3BvcnRMZWF2ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjbG9zZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcGVuXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcInBvc2l0aW9uQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2NvbnRhaW5lcicsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFbGVtZW50UmVmKVxuXSwgUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcImNvbnRlbnRDb250YWluZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZChSZXNpemVTZW5zb3JDb21wb25lbnQsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBSZXNpemVTZW5zb3JDb21wb25lbnQpXG5dLCBQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwicmVzaXplU2Vuc29yXCIsIHZvaWQgMCk7XG5Qb3B1cENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGV4cG9ydEFzOiAna2VuZG8tcG9wdXAnLFxuICAgICAgICBwcm92aWRlcnM6IFtBbGlnblNlcnZpY2UsIEFuaW1hdGlvblNlcnZpY2UsIERPTVNlcnZpY2UsIFBvc2l0aW9uU2VydmljZSwgUmVzaXplU2VydmljZSwgU2Nyb2xsYWJsZVNlcnZpY2VdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXBvcHVwJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGRpdiBjbGFzcz1cImstcG9wdXBcIiBbbmdDbGFzc109XCJwb3B1cENsYXNzXCIgI2NvbnRhaW5lcj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdUZW1wbGF0ZU91dGxldF09XCJjb250ZW50XCIgW25nSWZdPVwiY29udGVudFwiPjwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICA8a2VuZG8tcmVzaXplLXNlbnNvciBbcmF0ZUxpbWl0XT1cIjEwMFwiIChyZXNpemUpPVwib25SZXNpemUoKVwiPlxuICAgICAgICAgICAgPC9rZW5kby1yZXNpemUtc2Vuc29yPlxuICAgICAgICA8L2Rpdj5cbiAgICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZixcbiAgICAgICAgQWxpZ25TZXJ2aWNlLFxuICAgICAgICBET01TZXJ2aWNlLFxuICAgICAgICBQb3NpdGlvblNlcnZpY2UsXG4gICAgICAgIFJlc2l6ZVNlcnZpY2UsXG4gICAgICAgIFNjcm9sbGFibGVTZXJ2aWNlLFxuICAgICAgICBBbmltYXRpb25TZXJ2aWNlLFxuICAgICAgICBSZW5kZXJlcjIsXG4gICAgICAgIE5nWm9uZV0pXG5dLCBQb3B1cENvbXBvbmVudCk7XG5cbmNvbnN0IHJlbW92ZUVsZW1lbnQgPSAoZWxlbWVudCkgPT4ge1xuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgfVxufTtcbi8qKlxuICogVXNlZCB0byBpbmplY3QgdGhlIFBvcHVwIGNvbnRhaW5lci4gSWYgbm90IHByb3ZpZGVkLCB0aGUgZmlyc3Qgcm9vdCBjb21wb25lbnQgb2ZcbiAqIHRoZSBhcHBsaWNhdGlvbiBpcyB1c2VkLlxuICpcbiAqID4gVGhlIGBQT1BVUF9DT05UQUlORVJgIGNhbiBiZSB1c2VkIG9ubHkgd2l0aCB0aGUgW2BQb3B1cFNlcnZpY2VgXSh7JSBzbHVnIHNlcnZpY2VfcG9wdXAgJX0pIGNsYXNzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHMtbm8tcnVuXG4gKiAvLyBJbXBvcnQgdGhlIFBvcHVwIG1vZHVsZVxuICogaW1wb3J0IHsgUG9wdXBNb2R1bGUsIFBPUFVQX0NPTlRBSU5FUiB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLXBvcHVwJztcbiAqXG4gKiAvLyBUaGUgYnJvd3NlciBwbGF0Zm9ybSB3aXRoIGEgY29tcGlsZXJcbiAqIGltcG9ydCB7IHBsYXRmb3JtQnJvd3NlckR5bmFtaWMgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMnO1xuICpcbiAqIGltcG9ydCB7IEVsZW1lbnRSZWYsIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogLy8gSW1wb3J0IHRoZSBhcHAgY29tcG9uZW50XG4gKiBpbXBvcnQgeyBBcHBDb21wb25lbnQgfSBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xuICpcbiAqIC8vIERlZmluZSB0aGUgYXBwIG1vZHVsZVxuICogX0BOZ01vZHVsZSh7XG4gKiAgICAgZGVjbGFyYXRpb25zOiBbQXBwQ29tcG9uZW50XSwgLy8gZGVjbGFyZSBhcHAgY29tcG9uZW50XG4gKiAgICAgaW1wb3J0czogICAgICBbQnJvd3Nlck1vZHVsZSwgUG9wdXBNb2R1bGVdLCAvLyBpbXBvcnQgUG9wdXAgbW9kdWxlXG4gKiAgICAgYm9vdHN0cmFwOiAgICBbQXBwQ29tcG9uZW50XSxcbiAqICAgICBwcm92aWRlcnM6IFt7XG4gKiAgICAgICBwcm92aWRlOiBQT1BVUF9DT05UQUlORVIsXG4gKiAgICAgICB1c2VGYWN0b3J5OiAoKSA9PiB7XG4gKiAgICAgICAgICAvL3JldHVybiB0aGUgY29udGFpbmVyIEVsZW1lbnRSZWYsIHdoZXJlIHRoZSBwb3B1cCB3aWxsIGJlIGluamVjdGVkXG4gKiAgICAgICAgICByZXR1cm4geyBuYXRpdmVFbGVtZW50OiBkb2N1bWVudC5ib2R5IH0gYXMgRWxlbWVudFJlZjtcbiAqICAgICAgIH1cbiAqICAgICB9XVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge31cbiAqXG4gKiAvLyBDb21waWxlIGFuZCBsYXVuY2ggdGhlIG1vZHVsZVxuICogcGxhdGZvcm1Ccm93c2VyRHluYW1pYygpLmJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUpO1xuICogYGBgXG4gKi9cbmNvbnN0IFBPUFVQX0NPTlRBSU5FUiA9IG5ldyBJbmplY3Rpb25Ub2tlbignUG9wdXAgQ29udGFpbmVyJyk7XG4vKipcbiAqIEEgc2VydmljZSBmb3Igb3BlbmluZyBQb3B1cCBjb21wb25lbnRzIGR5bmFtaWNhbGx5XG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHNlcnZpY2VfcG9wdXAgJX0pKS5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgUG9wdXBTZXJ2aWNlXG4gKi9cbmxldCBQb3B1cFNlcnZpY2UgPSBjbGFzcyBQb3B1cFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGFwcGxpY2F0aW9uUmVmLCBjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIGluamVjdG9yLCBjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvblJlZiA9IGFwcGxpY2F0aW9uUmVmO1xuICAgICAgICB0aGlzLmNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IGNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcm9vdCB2aWV3IGNvbnRhaW5lciBpbnRvIHdoaWNoIHRoZSBjb21wb25lbnQgd2lsbCBiZSBpbmplY3RlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wb25lbnRSZWY8YW55Pn1cbiAgICAgKi9cbiAgICBnZXQgcm9vdFZpZXdDb250YWluZXIoKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi80LjAueC9wYWNrYWdlcy9jb3JlL3NyYy9hcHBsaWNhdGlvbl9yZWYudHMjTDU3MVxuICAgICAgICBjb25zdCByb290Q29tcG9uZW50cyA9IHRoaXMuYXBwbGljYXRpb25SZWYuY29tcG9uZW50cyB8fCBbXTtcbiAgICAgICAgaWYgKHJvb3RDb21wb25lbnRzWzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gcm9vdENvbXBvbmVudHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcbiAgICAgICAgICAgIFZpZXcgQ29udGFpbmVyIG5vdCBmb3VuZCEgSW5qZWN0IHRoZSBQT1BVUF9DT05UQUlORVIgb3IgZGVmaW5lIGEgc3BlY2lmaWMgVmlld0NvbnRhaW5lclJlZiB2aWEgdGhlIGFwcGVuZFRvIG9wdGlvbi5cbiAgICAgICAgICAgIFNlZSBodHRwOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9wb3B1cC9hcGkvUE9QVVBfQ09OVEFJTkVSLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICBgKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBvciBnZXRzIHRoZSBIVE1MIGVsZW1lbnQgb2YgdGhlIHJvb3QgY29tcG9uZW50IGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICBnZXQgcm9vdFZpZXdDb250YWluZXJOb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIgPyB0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50IDogdGhpcy5nZXRDb21wb25lbnRSb290Tm9kZSh0aGlzLnJvb3RWaWV3Q29udGFpbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbnMgYSBQb3B1cCBjb21wb25lbnQuIENyZWF0ZWQgUG9wdXBzIGFyZSBtb3VudGVkXG4gICAgICogaW4gdGhlIERPTSBkaXJlY3RseSBpbiB0aGUgcm9vdCBhcHBsaWNhdGlvbiBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BvcHVwU2V0dGluZ3N9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB3aGljaCBkZWZpbmUgdGhlIFBvcHVwLlxuICAgICAqIEByZXR1cm5zIHtDb21wb25lbnRSZWY8UG9wdXBDb21wb25lbnQ+fSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBQb3B1cCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHMtbm8tcnVuXG4gICAgICogX0BDb21wb25lbnQoe1xuICAgICAqICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqICAgdGVtcGxhdGU6IGBcbiAgICAgKiAgICAgPG5nLXRlbXBsYXRlICN0ZW1wbGF0ZT5cbiAgICAgKiAgICAgIFBvcHVwIGNvbnRlbnRcbiAgICAgKiAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiAgICAgPGJ1dHRvbiAjYW5jaG9yIGtlbmRvQnV0dG9uIChjbGljayk9XCJvcGVuKGFuY2hvciwgdGVtcGxhdGUpXCI+T3BlbjwvYnV0dG9uPlxuICAgICAqICAgYFxuICAgICAqIH0pXG4gICAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICogICAgIHB1YmxpYyBwb3B1cFJlZjogUG9wdXBSZWY7XG4gICAgICpcbiAgICAgKiAgICAgY29uc3RydWN0b3IoIHByaXZhdGUgcG9wdXBTZXJ2aWNlOiBQb3B1cFNlcnZpY2UgKSB7fVxuICAgICAqXG4gICAgICogICAgIHB1YmxpYyBvcGVuKGFuY2hvcjogRWxlbWVudFJlZiwgdGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4pOiB2b2lkIHtcbiAgICAgKiAgICAgICAgIGlmICh0aGlzLnBvcHVwUmVmKSB7XG4gICAgICogICAgICAgICAgICAgIHRoaXMucG9wdXBSZWYuY2xvc2UoKTtcbiAgICAgKiAgICAgICAgICAgICAgdGhpcy5wb3B1cFJlZiA9IG51bGw7XG4gICAgICogICAgICAgICAgICAgIHJldHVybjtcbiAgICAgKiAgICAgICAgIH1cbiAgICAgKlxuICAgICAqICAgICAgICAgdGhpcy5wb3B1cFJlZiA9IHRoaXMucG9wdXBTZXJ2aWNlLm9wZW4oe1xuICAgICAqICAgICAgICAgICBhbmNob3I6IGFuY2hvcixcbiAgICAgKiAgICAgICAgICAgY29udGVudDogdGVtcGxhdGVcbiAgICAgKiAgICAgICAgIH0pO1xuICAgICAqICAgICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG9wZW4ob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgY29tcG9uZW50LCBub2RlcyB9ID0gdGhpcy5jb250ZW50RnJvbShvcHRpb25zLmNvbnRlbnQpO1xuICAgICAgICBjb25zdCBwb3B1cENvbXBvbmVudFJlZiA9IHRoaXMuYXBwZW5kUG9wdXAobm9kZXMsIG9wdGlvbnMuYXBwZW5kVG8pO1xuICAgICAgICBjb25zdCBwb3B1cEluc3RhbmNlID0gcG9wdXBDb21wb25lbnRSZWYuaW5zdGFuY2U7XG4gICAgICAgIHRoaXMucHJvamVjdENvbXBvbmVudElucHV0cyhwb3B1cENvbXBvbmVudFJlZiwgb3B0aW9ucyk7XG4gICAgICAgIHBvcHVwQ29tcG9uZW50UmVmLmNoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgY29tcG9uZW50LmNoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3B1cEVsZW1lbnQgPSB0aGlzLmdldENvbXBvbmVudFJvb3ROb2RlKHBvcHVwQ29tcG9uZW50UmVmKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3B1cENvbXBvbmVudFJlZi5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgLy8gQW5ndWxhciB3aWxsIG5vdCByZW1vdmUgdGhlIGVsZW1lbnQgdW5sZXNzIHRoZSBjaGFuZ2UgZGV0ZWN0aW9uIGlzIHRyaWdnZXJlZFxuICAgICAgICAgICAgICAgIHJlbW92ZUVsZW1lbnQocG9wdXBFbGVtZW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZW50OiBjb21wb25lbnQsXG4gICAgICAgICAgICBwb3B1cDogcG9wdXBDb21wb25lbnRSZWYsXG4gICAgICAgICAgICBwb3B1cEFuY2hvclZpZXdwb3J0TGVhdmU6IHBvcHVwSW5zdGFuY2UuYW5jaG9yVmlld3BvcnRMZWF2ZSxcbiAgICAgICAgICAgIHBvcHVwQ2xvc2U6IHBvcHVwSW5zdGFuY2UuY2xvc2UsXG4gICAgICAgICAgICBwb3B1cEVsZW1lbnQ6IHBvcHVwRWxlbWVudCxcbiAgICAgICAgICAgIHBvcHVwT3BlbjogcG9wdXBJbnN0YW5jZS5vcGVuLFxuICAgICAgICAgICAgcG9wdXBQb3NpdGlvbkNoYW5nZTogcG9wdXBJbnN0YW5jZS5wb3NpdGlvbkNoYW5nZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBhcHBlbmRQb3B1cChub2RlcywgY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnN0IHBvcHVwQ29tcG9uZW50UmVmID0gdGhpcy5jcmVhdGVDb21wb25lbnQoUG9wdXBDb21wb25lbnQsIG5vZGVzLCBjb250YWluZXIpO1xuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5yb290Vmlld0NvbnRhaW5lck5vZGUuYXBwZW5kQ2hpbGQodGhpcy5nZXRDb21wb25lbnRSb290Tm9kZShwb3B1cENvbXBvbmVudFJlZikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3B1cENvbXBvbmVudFJlZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgSFRNTCBlbGVtZW50IGZvciBhIGNvbXBvbmVudCByZWZlcmVuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NvbXBvbmVudFJlZjxhbnk+fSBjb21wb25lbnRSZWZcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgZ2V0Q29tcG9uZW50Um9vdE5vZGUoY29tcG9uZW50UmVmKSB7XG4gICAgICAgIHJldHVybiBjb21wb25lbnRSZWYubG9jYXRpb24ubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYENvbXBvbmVudEZhY3RvcnlgIGluc3RhbmNlIGJ5IGl0cyB0eXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBjb21wb25lbnRDbGFzc1xuICAgICAqIEBwYXJhbSB7Kn0gbm9kZXNcbiAgICAgKiBAcmV0dXJucyB7Q29tcG9uZW50UmVmPGFueT59XG4gICAgICovXG4gICAgZ2V0Q29tcG9uZW50RmFjdG9yeShjb21wb25lbnRDbGFzcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoY29tcG9uZW50Q2xhc3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29tcG9uZW50IHJlZmVyZW5jZSBmcm9tIGEgYENvbXBvbmVudGAgdHlwZSBjbGFzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gY29tcG9uZW50Q2xhc3NcbiAgICAgKiBAcGFyYW0geyp9IG5vZGVzXG4gICAgICogQHJldHVybnMge0NvbXBvbmVudFJlZjxhbnk+fVxuICAgICAqL1xuICAgIGNyZWF0ZUNvbXBvbmVudChjb21wb25lbnRDbGFzcywgbm9kZXMsIGNvbnRhaW5lcikge1xuICAgICAgICBjb25zdCBmYWN0b3J5ID0gdGhpcy5nZXRDb21wb25lbnRGYWN0b3J5KGNvbXBvbmVudENsYXNzKTtcbiAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5jcmVhdGVDb21wb25lbnQoZmFjdG9yeSwgdW5kZWZpbmVkLCB0aGlzLmluamVjdG9yLCBub2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBmYWN0b3J5LmNyZWF0ZSh0aGlzLmluamVjdG9yLCBub2Rlcyk7XG4gICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uUmVmLmF0dGFjaFZpZXcoY29tcG9uZW50Lmhvc3RWaWV3KTtcbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvamVjdHMgdGhlIGlucHV0cyBvbiB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDb21wb25lbnRSZWY8YW55Pn0gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHsqfSBvcHRpb25zXG4gICAgICogQHJldHVybnMge0NvbXBvbmVudFJlZjxhbnk+fVxuICAgICAqL1xuICAgIHByb2plY3RDb21wb25lbnRJbnB1dHMoY29tcG9uZW50LCBvcHRpb25zKSB7XG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9wdGlvbnMpXG4gICAgICAgICAgICAuZmlsdGVyKHByb3AgPT4gcHJvcCAhPT0gJ2NvbnRlbnQnIHx8IG9wdGlvbnMuY29udGVudCBpbnN0YW5jZW9mIFRlbXBsYXRlUmVmKVxuICAgICAgICAgICAgLm1hcCgocHJvcCkgPT4ge1xuICAgICAgICAgICAgY29tcG9uZW50Lmluc3RhbmNlW3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNvbXBvbmVudCBhbmQgdGhlIG5vZGVzIHRvIGFwcGVuZCBmcm9tIHRoZSBgY29udGVudGAgb3B0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBjb250ZW50XG4gICAgICogQHJldHVybnMge2FueX1cbiAgICAgKi9cbiAgICBjb250ZW50RnJvbShjb250ZW50KSB7XG4gICAgICAgIGlmICghY29udGVudCB8fCBjb250ZW50IGluc3RhbmNlb2YgVGVtcGxhdGVSZWYpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNvbXBvbmVudDogbnVsbCwgbm9kZXM6IFtbXV0gfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLmNyZWF0ZUNvbXBvbmVudChjb250ZW50KTtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBjb21wb25lbnQgPyBbY29tcG9uZW50LmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnRdIDogW107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgICAgICAgICAgIG5vZGVzOiBbXG4gICAgICAgICAgICAgICAgbm9kZXMgLy8gPG5nLWNvbnRlbnQ+XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxufTtcblBvcHVwU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX3BhcmFtKDMsIEluamVjdChQT1BVUF9DT05UQUlORVIpKSwgX19wYXJhbSgzLCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0FwcGxpY2F0aW9uUmVmLFxuICAgICAgICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgICAgIEluamVjdG9yLFxuICAgICAgICBFbGVtZW50UmVmXSlcbl0sIFBvcHVwU2VydmljZSk7XG5cbmNvbnN0IFBPUFVQX0RJUkVDVElWRVMgPSBbUG9wdXBDb21wb25lbnRdO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgUG9wdXAgY29tcG9uZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHMtbm8tcnVuXG4gKiAvLyBJbXBvcnQgdGhlIFBvcHVwIG1vZHVsZVxuICogaW1wb3J0IHsgUG9wdXBNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1wb3B1cCc7XG4gKlxuICogLy8gVGhlIGJyb3dzZXIgcGxhdGZvcm0gd2l0aCBhIGNvbXBpbGVyXG4gKiBpbXBvcnQgeyBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJztcbiAqXG4gKiBpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIC8vIEltcG9ydCB0aGUgYXBwIGNvbXBvbmVudFxuICogaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSAnLi9hcHAuY29tcG9uZW50JztcbiAqXG4gKiAvLyBEZWZpbmUgdGhlIGFwcCBtb2R1bGVcbiAqIF9ATmdNb2R1bGUoe1xuICogICAgIGRlY2xhcmF0aW9uczogW0FwcENvbXBvbmVudF0sIC8vIGRlY2xhcmUgYXBwIGNvbXBvbmVudFxuICogICAgIGltcG9ydHM6ICAgICAgW0Jyb3dzZXJNb2R1bGUsIFBvcHVwTW9kdWxlXSwgLy8gaW1wb3J0IFBvcHVwIG1vZHVsZVxuICogICAgIGJvb3RzdHJhcDogICAgW0FwcENvbXBvbmVudF1cbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHt9XG4gKlxuICogLy8gQ29tcGlsZSBhbmQgbGF1bmNoIHRoZSBtb2R1bGVcbiAqIHBsYXRmb3JtQnJvd3NlckR5bmFtaWMoKS5ib290c3RyYXBNb2R1bGUoQXBwTW9kdWxlKTtcbiAqXG4gKiBgYGBcbiAqL1xubGV0IFBvcHVwTW9kdWxlID0gY2xhc3MgUG9wdXBNb2R1bGUge1xufTtcblBvcHVwTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtQT1BVUF9ESVJFQ1RJVkVTXSxcbiAgICAgICAgZW50cnlDb21wb25lbnRzOiBbUE9QVVBfRElSRUNUSVZFU10sXG4gICAgICAgIGV4cG9ydHM6IFtQT1BVUF9ESVJFQ1RJVkVTXSxcbiAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgUmVzaXplU2Vuc29yTW9kdWxlXSxcbiAgICAgICAgcHJvdmlkZXJzOiBbUG9wdXBTZXJ2aWNlXVxuICAgIH0pXG5dLCBQb3B1cE1vZHVsZSk7XG5cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cblxuZXhwb3J0IHsgQWxpZ25TZXJ2aWNlLCBBbmltYXRpb25TZXJ2aWNlLCBET01TZXJ2aWNlLCBQb3NpdGlvblNlcnZpY2UsIFJlc2l6ZVNlcnZpY2UsIFNjcm9sbGFibGVTZXJ2aWNlLCBQb3B1cFNlcnZpY2UsIFBPUFVQX0NPTlRBSU5FUiwgUG9wdXBDb21wb25lbnQsIFBvcHVwTW9kdWxlLCBTQ0FMRSB9O1xuIl19","map":null,"metadata":{},"sourceType":"module"}