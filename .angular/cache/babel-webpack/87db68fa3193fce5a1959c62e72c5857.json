{"ast":null,"code":"const proxy = (a, b) => e => b(a(e));\n\nconst bind = (el, event, callback) => el.addEventListener && el.addEventListener(event, callback);\n\nconst unbind = (el, event, callback) => el && el.removeEventListener && el.removeEventListener(event, callback);\n\nconst noop = () => {\n  /* empty */\n};\n\nconst preventDefault = e => e.preventDefault();\n\nconst touchRegExp = /touch/; // 300ms is the usual mouse interval;\n// // However, an underpowered mobile device under a heavy load may queue mouse events for a longer period.\n\nconst IGNORE_MOUSE_TIMEOUT = 2000;\n\nfunction normalizeEvent(e) {\n  if (e.type.match(touchRegExp)) {\n    return {\n      pageX: e.changedTouches[0].pageX,\n      pageY: e.changedTouches[0].pageY,\n      clientX: e.changedTouches[0].clientX,\n      clientY: e.changedTouches[0].clientY,\n      type: e.type,\n      originalEvent: e,\n      isTouch: true\n    };\n  }\n\n  return {\n    pageX: e.pageX,\n    pageY: e.pageY,\n    clientX: e.clientX,\n    clientY: e.clientY,\n    offsetX: e.offsetX,\n    offsetY: e.offsetY,\n    type: e.type,\n    ctrlKey: e.ctrlKey,\n    shiftKey: e.shiftKey,\n    altKey: e.altKey,\n    originalEvent: e\n  };\n}\n\nexport let Draggable = /*#__PURE__*/(() => {\n  class Draggable {\n    static supportPointerEvent() {\n      return typeof window !== 'undefined' && window.PointerEvent;\n    }\n\n    get document() {\n      return this._element ? this._element.ownerDocument : document;\n    }\n\n    constructor({\n      press = noop,\n      drag = noop,\n      release = noop,\n      mouseOnly = false\n    }) {\n      this._pressHandler = proxy(normalizeEvent, press);\n      this._dragHandler = proxy(normalizeEvent, drag);\n      this._releaseHandler = proxy(normalizeEvent, release);\n      this._ignoreMouse = false;\n      this._mouseOnly = mouseOnly;\n\n      this._touchstart = e => {\n        if (e.touches.length === 1) {\n          this._pressHandler(e);\n        }\n      };\n\n      this._touchmove = e => {\n        if (e.touches.length === 1) {\n          this._dragHandler(e);\n        }\n      };\n\n      this._touchend = e => {\n        // the last finger has been lifted, and the user is not doing gesture.\n        // there might be a better way to handle this.\n        if (e.touches.length === 0 && e.changedTouches.length === 1) {\n          this._releaseHandler(e);\n\n          this._ignoreMouse = true;\n          setTimeout(this._restoreMouse, IGNORE_MOUSE_TIMEOUT);\n        }\n      };\n\n      this._restoreMouse = () => {\n        this._ignoreMouse = false;\n      };\n\n      this._mousedown = e => {\n        const {\n          which\n        } = e;\n\n        if (which && which > 1 || this._ignoreMouse) {\n          return;\n        }\n\n        bind(this.document, \"mousemove\", this._mousemove);\n        bind(this.document, \"mouseup\", this._mouseup);\n\n        this._pressHandler(e);\n      };\n\n      this._mousemove = e => {\n        this._dragHandler(e);\n      };\n\n      this._mouseup = e => {\n        unbind(this.document, \"mousemove\", this._mousemove);\n        unbind(this.document, \"mouseup\", this._mouseup);\n\n        this._releaseHandler(e);\n      };\n\n      this._pointerdown = e => {\n        if (e.isPrimary && e.button === 0) {\n          bind(this.document, \"pointermove\", this._pointermove);\n          bind(this.document, \"pointerup\", this._pointerup);\n          bind(this.document, \"pointercancel\", this._pointerup);\n          bind(this.document, \"contextmenu\", preventDefault);\n\n          this._pressHandler(e);\n        }\n      };\n\n      this._pointermove = e => {\n        if (e.isPrimary) {\n          this._dragHandler(e);\n        }\n      };\n\n      this._pointerup = e => {\n        if (e.isPrimary) {\n          unbind(this.document, \"pointermove\", this._pointermove);\n          unbind(this.document, \"pointerup\", this._pointerup);\n          unbind(this.document, \"pointercancel\", this._pointerup);\n          unbind(this.document, \"contextmenu\", preventDefault);\n\n          this._releaseHandler(e);\n        }\n      };\n    }\n\n    bindTo(element) {\n      if (element === this._element) {\n        return;\n      }\n\n      if (this._element) {\n        this._unbindFromCurrent();\n      }\n\n      this._element = element;\n\n      this._bindToCurrent();\n    }\n\n    _bindToCurrent() {\n      const element = this._element;\n\n      if (this._usePointers()) {\n        bind(element, \"pointerdown\", this._pointerdown);\n        return;\n      }\n\n      bind(element, \"mousedown\", this._mousedown);\n\n      if (!this._mouseOnly) {\n        bind(element, \"touchstart\", this._touchstart);\n        bind(element, \"touchmove\", this._touchmove);\n        bind(element, \"touchend\", this._touchend);\n      }\n    }\n\n    _unbindFromCurrent() {\n      const element = this._element;\n\n      if (this._usePointers()) {\n        unbind(element, \"pointerdown\", this._pointerdown);\n        unbind(this.document, \"pointermove\", this._pointermove);\n        unbind(this.document, \"pointerup\", this._pointerup);\n        unbind(this.document, \"contextmenu\", preventDefault);\n        unbind(this.document, \"pointercancel\", this._pointerup);\n        return;\n      }\n\n      unbind(element, \"mousedown\", this._mousedown);\n\n      if (!this._mouseOnly) {\n        unbind(element, \"touchstart\", this._touchstart);\n        unbind(element, \"touchmove\", this._touchmove);\n        unbind(element, \"touchend\", this._touchend);\n      }\n    }\n\n    _usePointers() {\n      return !this._mouseOnly && Draggable.supportPointerEvent();\n    }\n\n    update({\n      press = noop,\n      drag = noop,\n      release = noop,\n      mouseOnly = false\n    }) {\n      this._pressHandler = proxy(normalizeEvent, press);\n      this._dragHandler = proxy(normalizeEvent, drag);\n      this._releaseHandler = proxy(normalizeEvent, release);\n      this._mouseOnly = mouseOnly;\n    }\n\n    destroy() {\n      this._unbindFromCurrent();\n\n      this._element = null;\n    }\n\n  }\n\n  // Re-export as \"default\" field to address a bug\n  // where the ES Module is imported by CommonJS code.\n  //\n  // See https://github.com/telerik/kendo-angular/issues/1314\n  Draggable.default = Draggable; // Rollup won't output exports['default'] otherwise\n\n  return Draggable;\n})();\nexport default Draggable;","map":null,"metadata":{},"sourceType":"module"}