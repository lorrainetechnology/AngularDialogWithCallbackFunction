{"ast":null,"code":"/**-----------------------------------------------------------------------------------------\n* Copyright © 2021 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport { __decorate, __metadata } from 'tslib';\nimport { EventEmitter, Input, Output, Directive, ElementRef, NgZone, NgModule, Renderer2, Injectable, Component } from '@angular/core';\nimport Draggable from '@telerik/kendo-draggable';\nimport { CommonModule } from '@angular/common';\nimport { auditTime } from 'rxjs/operators';\nimport { merge, fromEvent, from } from 'rxjs';\nimport * as ɵngcc0 from '@angular/core';\n\nconst isDocumentAvailable = () => typeof document !== 'undefined';\n\nconst isChanged = (propertyName, changes, skipFirstChange = true) => typeof changes[propertyName] !== 'undefined' && (!changes[propertyName].isFirstChange() || !skipFirstChange) && changes[propertyName].previousValue !== changes[propertyName].currentValue;\n\nconst anyChanged = (propertyNames, changes, skipFirstChange = true) => propertyNames.some(name => isChanged(name, changes, skipFirstChange));\n\nconst hasObservers = emitter => emitter && emitter.observers.length > 0;\n\nconst guid = () => {\n  let id = \"\";\n\n  for (let i = 0; i < 32; i++) {\n    const random = Math.random() * 16 | 0; // tslint:disable-line:no-bitwise\n\n    if (i === 8 || i === 12 || i === 16 || i === 20) {\n      id += \"-\";\n    } // tslint:disable-next-line:no-bitwise\n\n\n    id += (i === 12 ? 4 : i === 16 ? random & 3 | 8 : random).toString(16);\n  }\n\n  return id;\n};\n\nlet DraggableDirective = /*#__PURE__*/(() => {\n  let DraggableDirective = class DraggableDirective {\n    constructor(element, ngZone) {\n      this.element = element;\n      this.ngZone = ngZone;\n      this.enableDrag = true;\n      this.kendoPress = new EventEmitter();\n      this.kendoDrag = new EventEmitter();\n      this.kendoRelease = new EventEmitter();\n    }\n\n    ngOnInit() {\n      this.toggleDraggable();\n    }\n\n    ngOnChanges(changes) {\n      if (isChanged('enableDrag', changes)) {\n        this.toggleDraggable();\n      }\n    }\n\n    ngOnDestroy() {\n      this.destroyDraggable();\n    }\n\n    toggleDraggable() {\n      if (isDocumentAvailable()) {\n        this.destroyDraggable();\n\n        if (this.enableDrag) {\n          this.draggable = new Draggable({\n            drag: e => this.kendoDrag.next(e),\n            press: e => this.kendoPress.next(e),\n            release: e => this.kendoRelease.next(e)\n          });\n          this.ngZone.runOutsideAngular(() => this.draggable.bindTo(this.element.nativeElement));\n        }\n      }\n    }\n\n    destroyDraggable() {\n      if (this.draggable) {\n        this.draggable.destroy();\n        this.draggable = null;\n      }\n    }\n\n  };\n\n  DraggableDirective.ɵfac = function DraggableDirective_Factory(t) {\n    return new (t || DraggableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  DraggableDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DraggableDirective,\n    selectors: [[\"\", \"kendoDraggable\", \"\"]],\n    inputs: {\n      enableDrag: \"enableDrag\"\n    },\n    outputs: {\n      kendoPress: \"kendoPress\",\n      kendoDrag: \"kendoDrag\",\n      kendoRelease: \"kendoRelease\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", Boolean)], DraggableDirective.prototype, \"enableDrag\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], DraggableDirective.prototype, \"kendoPress\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], DraggableDirective.prototype, \"kendoDrag\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], DraggableDirective.prototype, \"kendoRelease\", void 0);\n\n  DraggableDirective = __decorate([__metadata(\"design:paramtypes\", [ElementRef, NgZone])], DraggableDirective);\n  /**\n   * @hidden\n   */\n\n  return DraggableDirective;\n})();\nlet DraggableModule = /*#__PURE__*/(() => {\n  let DraggableModule = class DraggableModule {};\n\n  DraggableModule.ɵfac = function DraggableModule_Factory(t) {\n    return new (t || DraggableModule)();\n  };\n\n  DraggableModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: DraggableModule\n  });\n  DraggableModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return DraggableModule;\n})();\n\nconst closestInScope = (node, predicate, scope) => {\n  while (node && node !== scope && !predicate(node)) {\n    node = node.parentNode;\n  }\n\n  if (node !== scope) {\n    return node;\n  }\n};\n\nconst closest = (node, predicate) => {\n  while (node && !predicate(node)) {\n    node = node.parentNode;\n  }\n\n  return node;\n};\n\nconst contains = (parent, node, matchSelf = false) => {\n  const outside = !closest(node, child => child === parent);\n\n  if (outside) {\n    return false;\n  }\n\n  const el = closest(node, child => child === node);\n  return el && (matchSelf || el !== parent);\n};\n\nconst findElement = (node, predicate, matchSelf = true) => {\n  if (!node) {\n    return;\n  }\n\n  if (matchSelf && predicate(node)) {\n    return node;\n  }\n\n  node = node.firstChild;\n\n  while (node) {\n    if (node.nodeType === 1) {\n      const element = findElement(node, predicate);\n\n      if (element) {\n        return element;\n      }\n    }\n\n    node = node.nextSibling;\n  }\n};\n\nconst focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;\n\nconst isFocusable = element => {\n  if (!element.tagName) {\n    return false;\n  }\n\n  const tagName = element.tagName.toLowerCase();\n  const hasTabIndex = Boolean(element.getAttribute('tabIndex'));\n  const focusable = !element.disabled && focusableRegex.test(tagName);\n  return focusable || hasTabIndex;\n};\n\nconst isVisible = element => {\n  const rect = element.getBoundingClientRect();\n  const hasSize = rect.width > 0 && rect.height > 0;\n  const hasPosition = rect.x !== 0 && rect.y !== 0; // Elements can have zero size due to styling, but they will still count as visible.\n  // For example, the selection checkbox has no size, but is made visible through styling.\n\n  return (hasSize || hasPosition) && window.getComputedStyle(element).visibility !== 'hidden';\n};\n\nconst isFocusableWithTabKey = (element, checkVisibility = true) => {\n  if (!isFocusable(element)) {\n    return false;\n  }\n\n  const tabIndex = element.getAttribute('tabIndex');\n  const visible = !checkVisibility || isVisible(element);\n  return visible && tabIndex !== '-1';\n};\n\nconst findFocusableChild = (element, checkVisibility = true) => {\n  return findElement(element, node => isFocusableWithTabKey(node, checkVisibility), false);\n};\n\nconst findFocusable = (element, checkVisibility = true) => {\n  return findElement(element, node => isFocusableWithTabKey(node, checkVisibility));\n};\n\nconst toClassList = classNames => String(classNames).trim().split(' ');\n\nconst hasClasses = (element, classNames) => {\n  const namesList = toClassList(classNames);\n  return Boolean(toClassList(element.className).find(className => namesList.indexOf(className) >= 0));\n};\n\nconst matchesClasses = classNames => element => hasClasses(element, classNames);\n\nconst NODE_NAME_PREDICATES = {};\n\nconst matchesNodeName = nodeName => {\n  if (!NODE_NAME_PREDICATES[nodeName]) {\n    NODE_NAME_PREDICATES[nodeName] = element => String(element.nodeName).toLowerCase() === nodeName.toLowerCase();\n  }\n\n  return NODE_NAME_PREDICATES[nodeName];\n};\n/**\n * Normalizes a scroll position value in RTL mode.\n */\n\n\nfunction rtlScrollPosition(position, element, initial) {\n  let result = position;\n\n  if (initial < 0) {\n    result = -position;\n  } else if (initial > 0) {\n    result = element.scrollWidth - element.offsetWidth - position;\n  }\n\n  return result;\n}\n/* tslint:disable:no-input-rename */\n\n/**\n * @hidden\n */\n\n\nlet EventsOutsideAngularDirective = /*#__PURE__*/(() => {\n  let EventsOutsideAngularDirective = class EventsOutsideAngularDirective {\n    constructor(element, ngZone, renderer) {\n      this.element = element;\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n      this.events = {};\n    }\n\n    ngOnInit() {\n      if (!this.element || !this.element.nativeElement) {\n        return;\n      }\n\n      const events = this.events;\n      this.subscriptions = [];\n      this.ngZone.runOutsideAngular(() => {\n        for (let name in events) {\n          if (events.hasOwnProperty(name)) {\n            this.subscriptions.push(this.renderer.listen(this.element.nativeElement, name, this.scope ? events[name].bind(this.scope) : events[name]));\n          }\n        }\n      });\n    }\n\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        for (let idx = 0; idx < this.subscriptions.length; idx++) {\n          this.subscriptions[idx]();\n        }\n\n        this.subscriptions = null;\n      }\n    }\n\n  };\n\n  EventsOutsideAngularDirective.ɵfac = function EventsOutsideAngularDirective_Factory(t) {\n    return new (t || EventsOutsideAngularDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  EventsOutsideAngularDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: EventsOutsideAngularDirective,\n    selectors: [[\"\", \"kendoEventsOutsideAngular\", \"\"]],\n    inputs: {\n      events: [\"kendoEventsOutsideAngular\", \"events\"],\n      scope: \"scope\"\n    }\n  });\n\n  __decorate([Input('kendoEventsOutsideAngular'), __metadata(\"design:type\", Object)], EventsOutsideAngularDirective.prototype, \"events\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], EventsOutsideAngularDirective.prototype, \"scope\", void 0);\n\n  EventsOutsideAngularDirective = __decorate([__metadata(\"design:paramtypes\", [ElementRef, NgZone, Renderer2])], EventsOutsideAngularDirective);\n  /**\n   * @hidden\n   */\n\n  return EventsOutsideAngularDirective;\n})();\nlet EventsModule = /*#__PURE__*/(() => {\n  let EventsModule = class EventsModule {};\n\n  EventsModule.ɵfac = function EventsModule_Factory(t) {\n    return new (t || EventsModule)();\n  };\n\n  EventsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: EventsModule\n  });\n  EventsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return EventsModule;\n})();\n\nclass ResizeService {\n  constructor(resizeBatchService) {\n    this.resizeBatchService = resizeBatchService;\n    this.resize = new EventEmitter();\n    this.acceptedSize = false;\n    this.state = 0\n    /* Initial */\n    ;\n  }\n\n  acceptSize(size = this.measure()) {\n    this.lastWidth = size.width;\n    this.lastHeight = size.height;\n    this.acceptedSize = true;\n  }\n\n  checkChanges() {\n    if (!isDocumentAvailable()) {\n      return;\n    }\n\n    if (this.state === 0\n    /* Initial */\n    ) {\n      this.state = 1\n      /* Initializing */\n      ; // batch initial measure\n\n      this.resizeBatchService.schedule(this, this.init);\n    }\n  }\n\n  destroy() {\n    this.resizeBatchService.cancel(this);\n  }\n\n  checkSize() {\n    if (!this.parentElement) {\n      return;\n    }\n\n    const {\n      width,\n      height\n    } = this.measure();\n    const sameSize = width === this.lastWidth && height === this.lastHeight;\n\n    if (sameSize) {\n      return;\n    }\n\n    this.lastWidth = width;\n    this.lastHeight = height;\n    this.acceptedSize = false;\n    this.resize.emit();\n    return true;\n  }\n\n  initSize() {\n    const size = this.measure();\n    this.lastWidth = size.width;\n    this.lastHeight = size.height;\n  }\n\n  measure() {\n    let width = 0;\n    let height = 0;\n\n    if (this.parentElement) {\n      height = this.parentElement.offsetHeight;\n      width = this.parentElement.offsetWidth;\n    }\n\n    return {\n      height,\n      width\n    };\n  }\n\n} // tslint:disable:deprecation\n\n\nconst div = style => {\n  const el = document.createElement('div');\n  el.style.cssText = style;\n  return el;\n};\n\nconst computedProp = (elem, prop) => getComputedStyle(elem, null).getPropertyValue(prop);\n\nconst WRAP_STYLE = 'position: absolute; display: block; left: 0; top: 0; right: 0; bottom: 0; z-index: -1;' + 'overflow: hidden; visibility: hidden;';\nconst EXPAND_CHILD_STYLE = 'position: absolute; left: 0; top: 0; transition: 0s;';\nconst SHRINK_CHILD_STYLE = EXPAND_CHILD_STYLE + 'width: 200%; height: 200%;';\n\nclass ResizeCompatService extends ResizeService {\n  constructor(resizeBatchService, element, ngZone) {\n    super(resizeBatchService);\n    this.element = element;\n    this.ngZone = ngZone;\n  }\n\n  checkChanges() {\n    if (this.state === 2\n    /* Initialized */\n    ) {\n      if (!this.resizeBatchService.isScheduled(this)) {\n        this.resizeBatchService.schedule(this, this.checkSize);\n      }\n\n      return;\n    }\n\n    super.checkChanges();\n  }\n\n  destroy() {\n    super.destroy();\n\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n    }\n\n    if (this.expand) {\n      const element = this.element.nativeElement;\n      element.removeChild(this.expand);\n      element.removeChild(this.shrink);\n      this.expand.removeChild(this.expandChild);\n      this.expand = this.expandChild = this.shrink = this.element = null;\n    }\n  }\n\n  checkSize() {\n    if (super.checkSize()) {\n      this.reset();\n      return true;\n    }\n  }\n\n  init() {\n    const parentElement = this.parentElement = this.element.nativeElement.parentElement;\n\n    if (computedProp(parentElement, 'position') === 'static') {\n      parentElement.style.position = 'relative';\n    }\n\n    this.state = 2\n    /* Initialized */\n    ;\n    this.render();\n    this.reset();\n    this.initSize();\n    this.subscribe();\n  }\n\n  render() {\n    const element = this.element.nativeElement;\n    element.style.cssText = WRAP_STYLE;\n    element.setAttribute('dir', 'ltr');\n    this.expand = div(WRAP_STYLE);\n    this.expandChild = div(EXPAND_CHILD_STYLE);\n    this.expand.appendChild(this.expandChild);\n    element.appendChild(this.expand);\n    this.shrink = div(WRAP_STYLE);\n    const shrinkChild = div(SHRINK_CHILD_STYLE);\n    this.shrink.appendChild(shrinkChild);\n    element.appendChild(this.shrink);\n  }\n\n  reset() {\n    const expandChild = this.expandChild;\n    expandChild.style.width = 100000 + 'px';\n    expandChild.style.height = 100000 + 'px';\n    const expand = this.expand;\n    expand.scrollLeft = 100000;\n    expand.scrollTop = 100000;\n    const shrink = this.shrink;\n    shrink.scrollLeft = 100000;\n    shrink.scrollTop = 100000;\n  }\n\n  subscribe() {\n    this.ngZone.runOutsideAngular(() => {\n      this.subscription = merge(fromEvent(this.shrink, 'scroll'), fromEvent(this.expand, 'scroll')).subscribe(() => {\n        this.checkSize();\n      });\n    });\n  }\n\n}\n\nconst HAS_OBSERVER = typeof ResizeObserver !== 'undefined';\n/**\n * @hidden\n */\n\nclass ResizeObserverService extends ResizeService {\n  constructor(resizeBatchService, element, ngZone) {\n    super(resizeBatchService);\n    this.element = element;\n    this.ngZone = ngZone;\n  }\n\n  static supported() {\n    return HAS_OBSERVER;\n  }\n\n  destroy() {\n    super.destroy();\n\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = null;\n    }\n\n    this.parentElement = null;\n  }\n\n  init() {\n    this.parentElement = this.element.nativeElement.parentElement;\n    this.initSize();\n    this.state = 2\n    /* Initialized */\n    ;\n    this.ngZone.runOutsideAngular(() => {\n      this.resizeObserver = new ResizeObserver(() => {\n        this.checkSize();\n      });\n      this.resizeObserver.observe(this.parentElement);\n    });\n  }\n\n}\n/**\n * @hidden\n */\n\n\nlet ResizeBatchService = /*#__PURE__*/(() => {\n  let ResizeBatchService = class ResizeBatchService {\n    constructor(ngZone) {\n      this.ngZone = ngZone;\n      this.scheduled = [];\n      this.resolvedPromise = Promise.resolve(null);\n      this.flush = this.flush.bind(this);\n    }\n\n    schedule(instance, method) {\n      this.scheduled.push({\n        instance,\n        method\n      });\n\n      if (!this.subscription) {\n        this.ngZone.runOutsideAngular(() => {\n          this.subscription = from(this.resolvedPromise).subscribe(this.flush);\n        });\n      }\n    }\n\n    isScheduled(instance) {\n      return Boolean(this.scheduled.find(item => item.instance === instance));\n    }\n\n    cancel(instance) {\n      const scheduled = this.scheduled;\n      const count = scheduled.length;\n\n      for (let idx = 0; idx < count; idx++) {\n        if (scheduled[idx].instance === instance) {\n          scheduled.splice(idx, 1);\n\n          if (!scheduled.length) {\n            this.unsubscribe();\n          }\n\n          return;\n        }\n      }\n    }\n\n    ngOnDestroy() {\n      this.unsubscribe();\n    }\n\n    unsubscribe() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n        this.subscription = null;\n      }\n    }\n\n    flush() {\n      this.scheduled.forEach(item => {\n        item.method.call(item.instance);\n      });\n      this.scheduled = [];\n      this.unsubscribe();\n    }\n\n  };\n\n  ResizeBatchService.ɵfac = function ResizeBatchService_Factory(t) {\n    return new (t || ResizeBatchService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n  };\n\n  ResizeBatchService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: ResizeBatchService,\n    factory: function (t) {\n      return ResizeBatchService.ɵfac(t);\n    }\n  });\n  ResizeBatchService = __decorate([__metadata(\"design:paramtypes\", [NgZone])], ResizeBatchService);\n  /**\n   * Emit up to 10 resize events per second by default.\n   * Chosen as a compromise between responsiveness and performance.\n   */\n\n  return ResizeBatchService;\n})();\nconst DEFAULT_RATE_LIMIT = 10;\n/**\n * Resize Sensor Component\n *\n * Triggers a \"resize\" event whenever the parent DOM element size changes.\n */\n\nlet ResizeSensorComponent = /*#__PURE__*/(() => {\n  let ResizeSensorComponent = class ResizeSensorComponent {\n    constructor(resizeBatchService, element, ngZone) {\n      /**\n       * The maximum number of resize events to emit per second.\n       *\n       * Defaults to 10.\n       */\n      this.rateLimit = DEFAULT_RATE_LIMIT;\n      /**\n       * Fires when the parent DOM element has been resized.\n       */\n\n      this.resize = new EventEmitter();\n      const serviceType = ResizeObserverService.supported() ? ResizeObserverService : ResizeCompatService;\n      this.resizeService = new serviceType(resizeBatchService, element, ngZone);\n      const throttleTime = 1000 / (this.rateLimit || DEFAULT_RATE_LIMIT);\n      this.subscription = this.resizeService.resize.pipe(auditTime(throttleTime)).subscribe(() => {\n        if (!this.resizeService.acceptedSize) {\n          this.resize.emit();\n        }\n      });\n    }\n\n    ngAfterViewChecked() {\n      this.resizeService.checkChanges();\n    }\n\n    ngOnDestroy() {\n      this.subscription.unsubscribe();\n      this.resizeService.destroy();\n    }\n\n    acceptSize(size) {\n      this.resizeService.acceptSize(size);\n    }\n\n  };\n\n  ResizeSensorComponent.ɵfac = function ResizeSensorComponent_Factory(t) {\n    return new (t || ResizeSensorComponent)(ɵngcc0.ɵɵdirectiveInject(ResizeBatchService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  ResizeSensorComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: ResizeSensorComponent,\n    selectors: [[\"kendo-resize-sensor\"]],\n    inputs: {\n      rateLimit: \"rateLimit\"\n    },\n    outputs: {\n      resize: \"resize\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function ResizeSensorComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", Number)], ResizeSensorComponent.prototype, \"rateLimit\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], ResizeSensorComponent.prototype, \"resize\", void 0);\n\n  ResizeSensorComponent = __decorate([__metadata(\"design:paramtypes\", [ResizeBatchService, ElementRef, NgZone])], ResizeSensorComponent);\n  return ResizeSensorComponent;\n})();\nconst COMPONENT_DIRECTIVES = [ResizeSensorComponent];\n/**\n * Resize Sensor module\n */\n\nlet ResizeSensorModule = /*#__PURE__*/(() => {\n  let ResizeSensorModule = class ResizeSensorModule {};\n\n  ResizeSensorModule.ɵfac = function ResizeSensorModule_Factory(t) {\n    return new (t || ResizeSensorModule)();\n  };\n\n  ResizeSensorModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: ResizeSensorModule\n  });\n  ResizeSensorModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [ResizeBatchService]\n  });\n  return ResizeSensorModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DraggableModule, {\n    declarations: function () {\n      return [DraggableDirective];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [DraggableDirective];\n    }\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(EventsModule, {\n    declarations: [EventsOutsideAngularDirective],\n    exports: [EventsOutsideAngularDirective]\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ResizeSensorModule, {\n    declarations: [ResizeSensorComponent],\n    exports: [ResizeSensorComponent]\n  });\n})();\n\nclass KendoInput {}\n/**\n * Enum with key codes.\n */\n\n\nvar Keys = /*#__PURE__*/(() => {\n  (function (Keys) {\n    Keys[Keys[\"Alt\"] = 18] = \"Alt\";\n    Keys[Keys[\"ArrowDown\"] = 40] = \"ArrowDown\";\n    Keys[Keys[\"ArrowLeft\"] = 37] = \"ArrowLeft\";\n    Keys[Keys[\"ArrowRight\"] = 39] = \"ArrowRight\";\n    Keys[Keys[\"ArrowUp\"] = 38] = \"ArrowUp\";\n    Keys[Keys[\"Backspace\"] = 8] = \"Backspace\";\n    Keys[Keys[\"Control\"] = 17] = \"Control\";\n    Keys[Keys[\"Delete\"] = 46] = \"Delete\";\n    Keys[Keys[\"Digit0\"] = 48] = \"Digit0\";\n    Keys[Keys[\"Digit1\"] = 49] = \"Digit1\";\n    Keys[Keys[\"Digit2\"] = 50] = \"Digit2\";\n    Keys[Keys[\"Digit3\"] = 51] = \"Digit3\";\n    Keys[Keys[\"Digit4\"] = 52] = \"Digit4\";\n    Keys[Keys[\"Digit5\"] = 53] = \"Digit5\";\n    Keys[Keys[\"Digit6\"] = 54] = \"Digit6\";\n    Keys[Keys[\"Digit7\"] = 55] = \"Digit7\";\n    Keys[Keys[\"Digit8\"] = 56] = \"Digit8\";\n    Keys[Keys[\"Digit9\"] = 57] = \"Digit9\";\n    Keys[Keys[\"End\"] = 35] = \"End\";\n    Keys[Keys[\"Enter\"] = 13] = \"Enter\";\n    Keys[Keys[\"Escape\"] = 27] = \"Escape\";\n    Keys[Keys[\"F1\"] = 112] = \"F1\";\n    Keys[Keys[\"F2\"] = 113] = \"F2\";\n    Keys[Keys[\"F10\"] = 121] = \"F10\";\n    Keys[Keys[\"Home\"] = 36] = \"Home\";\n    Keys[Keys[\"Insert\"] = 45] = \"Insert\";\n    Keys[Keys[\"KeyA\"] = 65] = \"KeyA\";\n    Keys[Keys[\"KeyB\"] = 66] = \"KeyB\";\n    Keys[Keys[\"KeyC\"] = 67] = \"KeyC\";\n    Keys[Keys[\"KeyD\"] = 68] = \"KeyD\";\n    Keys[Keys[\"KeyE\"] = 69] = \"KeyE\";\n    Keys[Keys[\"KeyF\"] = 70] = \"KeyF\";\n    Keys[Keys[\"KeyG\"] = 71] = \"KeyG\";\n    Keys[Keys[\"KeyH\"] = 72] = \"KeyH\";\n    Keys[Keys[\"KeyI\"] = 73] = \"KeyI\";\n    Keys[Keys[\"KeyJ\"] = 74] = \"KeyJ\";\n    Keys[Keys[\"KeyK\"] = 75] = \"KeyK\";\n    Keys[Keys[\"KeyL\"] = 76] = \"KeyL\";\n    Keys[Keys[\"KeyM\"] = 77] = \"KeyM\";\n    Keys[Keys[\"KeyN\"] = 78] = \"KeyN\";\n    Keys[Keys[\"KeyO\"] = 79] = \"KeyO\";\n    Keys[Keys[\"KeyP\"] = 80] = \"KeyP\";\n    Keys[Keys[\"KeyQ\"] = 81] = \"KeyQ\";\n    Keys[Keys[\"KeyR\"] = 82] = \"KeyR\";\n    Keys[Keys[\"KeyS\"] = 83] = \"KeyS\";\n    Keys[Keys[\"KeyT\"] = 84] = \"KeyT\";\n    Keys[Keys[\"KeyU\"] = 85] = \"KeyU\";\n    Keys[Keys[\"KeyV\"] = 86] = \"KeyV\";\n    Keys[Keys[\"KeyW\"] = 87] = \"KeyW\";\n    Keys[Keys[\"KeyX\"] = 88] = \"KeyX\";\n    Keys[Keys[\"KeyY\"] = 89] = \"KeyY\";\n    Keys[Keys[\"KeyZ\"] = 90] = \"KeyZ\";\n    Keys[Keys[\"NumpadDecimal\"] = 110] = \"NumpadDecimal\";\n    Keys[Keys[\"PageDown\"] = 34] = \"PageDown\";\n    Keys[Keys[\"PageUp\"] = 33] = \"PageUp\";\n    Keys[Keys[\"Shift\"] = 16] = \"Shift\";\n    Keys[Keys[\"Space\"] = 32] = \"Space\";\n    Keys[Keys[\"Tab\"] = 9] = \"Tab\";\n  })(Keys || (Keys = {}));\n\n  return Keys;\n})();\n\nclass PreventableEvent {\n  constructor() {\n    this.prevented = false;\n  }\n  /**\n   * Prevents the default action for a specified event.\n   * In this way, the source component suppresses\n   * the built-in behavior that follows the event.\n   */\n\n\n  preventDefault() {\n    this.prevented = true;\n  }\n  /**\n   * Returns `true` if the event was prevented\n   * by any of its subscribers.\n   *\n   * @returns `true` if the default action was prevented.\n   * Otherwise, returns `false`.\n   */\n\n\n  isDefaultPrevented() {\n    return this.prevented;\n  }\n\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ResizeService, PreventableEvent, DraggableDirective, DraggableModule, closestInScope, closest, contains, findElement, findFocusableChild, findFocusable, hasClasses, isFocusableWithTabKey, isFocusable, isVisible, matchesClasses, matchesNodeName, rtlScrollPosition, EventsOutsideAngularDirective, EventsModule, ResizeSensorComponent, ResizeBatchService, ResizeCompatService, ResizeObserverService, ResizeSensorModule, KendoInput, isDocumentAvailable, isChanged, anyChanged, hasObservers, guid, Keys }; //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvVEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzRGQU9vQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztzUEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzhEQU1pQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztnS0FBRTtBQUNGLGlDQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O21UQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUtHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bU1BT3VCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMSBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBfX2RlY29yYXRlLCBfX21ldGFkYXRhIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0LCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIE5nWm9uZSwgTmdNb2R1bGUsIFJlbmRlcmVyMiwgSW5qZWN0YWJsZSwgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgRHJhZ2dhYmxlIGZyb20gJ0B0ZWxlcmlrL2tlbmRvLWRyYWdnYWJsZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgYXVkaXRUaW1lIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgbWVyZ2UsIGZyb21FdmVudCwgZnJvbSB9IGZyb20gJ3J4anMnO1xuXG5jb25zdCBpc0RvY3VtZW50QXZhaWxhYmxlID0gKCkgPT4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxuY29uc3QgaXNDaGFuZ2VkID0gKHByb3BlcnR5TmFtZSwgY2hhbmdlcywgc2tpcEZpcnN0Q2hhbmdlID0gdHJ1ZSkgPT4gKHR5cGVvZiBjaGFuZ2VzW3Byb3BlcnR5TmFtZV0gIT09ICd1bmRlZmluZWQnICYmXG4gICAgKCFjaGFuZ2VzW3Byb3BlcnR5TmFtZV0uaXNGaXJzdENoYW5nZSgpIHx8ICFza2lwRmlyc3RDaGFuZ2UpICYmXG4gICAgY2hhbmdlc1twcm9wZXJ0eU5hbWVdLnByZXZpb3VzVmFsdWUgIT09IGNoYW5nZXNbcHJvcGVydHlOYW1lXS5jdXJyZW50VmFsdWUpO1xuXG5jb25zdCBhbnlDaGFuZ2VkID0gKHByb3BlcnR5TmFtZXMsIGNoYW5nZXMsIHNraXBGaXJzdENoYW5nZSA9IHRydWUpID0+IHByb3BlcnR5TmFtZXMuc29tZShuYW1lID0+IGlzQ2hhbmdlZChuYW1lLCBjaGFuZ2VzLCBza2lwRmlyc3RDaGFuZ2UpKTtcblxuY29uc3QgaGFzT2JzZXJ2ZXJzID0gKGVtaXR0ZXIpID0+IGVtaXR0ZXIgJiYgZW1pdHRlci5vYnNlcnZlcnMubGVuZ3RoID4gMDtcblxuY29uc3QgZ3VpZCA9ICgpID0+IHtcbiAgICBsZXQgaWQgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICBjb25zdCByYW5kb20gPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWJpdHdpc2VcbiAgICAgICAgaWYgKGkgPT09IDggfHwgaSA9PT0gMTIgfHwgaSA9PT0gMTYgfHwgaSA9PT0gMjApIHtcbiAgICAgICAgICAgIGlkICs9IFwiLVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXG4gICAgICAgIGlkICs9IChpID09PSAxMiA/IDQgOiAoaSA9PT0gMTYgPyAocmFuZG9tICYgMyB8IDgpIDogcmFuZG9tKSkudG9TdHJpbmcoMTYpO1xuICAgIH1cbiAgICByZXR1cm4gaWQ7XG59O1xuXG5sZXQgRHJhZ2dhYmxlRGlyZWN0aXZlID0gY2xhc3MgRHJhZ2dhYmxlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBuZ1pvbmUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMuZW5hYmxlRHJhZyA9IHRydWU7XG4gICAgICAgIHRoaXMua2VuZG9QcmVzcyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5rZW5kb0RyYWcgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMua2VuZG9SZWxlYXNlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy50b2dnbGVEcmFnZ2FibGUoKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoaXNDaGFuZ2VkKCdlbmFibGVEcmFnJywgY2hhbmdlcykpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlRHJhZ2dhYmxlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveURyYWdnYWJsZSgpO1xuICAgIH1cbiAgICB0b2dnbGVEcmFnZ2FibGUoKSB7XG4gICAgICAgIGlmIChpc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveURyYWdnYWJsZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlRHJhZykge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dhYmxlID0gbmV3IERyYWdnYWJsZSh7XG4gICAgICAgICAgICAgICAgICAgIGRyYWc6IChlKSA9PiB0aGlzLmtlbmRvRHJhZy5uZXh0KGUpLFxuICAgICAgICAgICAgICAgICAgICBwcmVzczogKGUpID0+IHRoaXMua2VuZG9QcmVzcy5uZXh0KGUpLFxuICAgICAgICAgICAgICAgICAgICByZWxlYXNlOiAoZSkgPT4gdGhpcy5rZW5kb1JlbGVhc2UubmV4dChlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHRoaXMuZHJhZ2dhYmxlLmJpbmRUbyh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3lEcmFnZ2FibGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2FibGUuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEcmFnZ2FibGVEaXJlY3RpdmUucHJvdG90eXBlLCBcImVuYWJsZURyYWdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBEcmFnZ2FibGVEaXJlY3RpdmUucHJvdG90eXBlLCBcImtlbmRvUHJlc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBEcmFnZ2FibGVEaXJlY3RpdmUucHJvdG90eXBlLCBcImtlbmRvRHJhZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERyYWdnYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwia2VuZG9SZWxlYXNlXCIsIHZvaWQgMCk7XG5EcmFnZ2FibGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0RyYWdnYWJsZV0nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBOZ1pvbmVdKVxuXSwgRHJhZ2dhYmxlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBEcmFnZ2FibGVNb2R1bGUgPSBjbGFzcyBEcmFnZ2FibGVNb2R1bGUge1xufTtcbkRyYWdnYWJsZU1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbRHJhZ2dhYmxlRGlyZWN0aXZlXSxcbiAgICAgICAgZXhwb3J0czogW0RyYWdnYWJsZURpcmVjdGl2ZV0sXG4gICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdXG4gICAgfSlcbl0sIERyYWdnYWJsZU1vZHVsZSk7XG5cbmNvbnN0IGNsb3Nlc3RJblNjb3BlID0gKG5vZGUsIHByZWRpY2F0ZSwgc2NvcGUpID0+IHtcbiAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSBzY29wZSAmJiAhcHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIGlmIChub2RlICE9PSBzY29wZSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG59O1xuXG5jb25zdCBjbG9zZXN0ID0gKG5vZGUsIHByZWRpY2F0ZSkgPT4ge1xuICAgIHdoaWxlIChub2RlICYmICFwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5jb25zdCBjb250YWlucyA9IChwYXJlbnQsIG5vZGUsIG1hdGNoU2VsZiA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3Qgb3V0c2lkZSA9ICFjbG9zZXN0KG5vZGUsIChjaGlsZCkgPT4gY2hpbGQgPT09IHBhcmVudCk7XG4gICAgaWYgKG91dHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBlbCA9IGNsb3Nlc3Qobm9kZSwgKGNoaWxkKSA9PiBjaGlsZCA9PT0gbm9kZSk7XG4gICAgcmV0dXJuIGVsICYmIChtYXRjaFNlbGYgfHwgZWwgIT09IHBhcmVudCk7XG59O1xuXG5jb25zdCBmaW5kRWxlbWVudCA9IChub2RlLCBwcmVkaWNhdGUsIG1hdGNoU2VsZiA9IHRydWUpID0+IHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWF0Y2hTZWxmICYmIHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGZpbmRFbGVtZW50KG5vZGUsIHByZWRpY2F0ZSk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbn07XG5cbmNvbnN0IGZvY3VzYWJsZVJlZ2V4ID0gL14oPzphfGlucHV0fHNlbGVjdHxvcHRpb258dGV4dGFyZWF8YnV0dG9ufG9iamVjdCkkL2k7XG5jb25zdCBpc0ZvY3VzYWJsZSA9IChlbGVtZW50KSA9PiB7XG4gICAgaWYgKCFlbGVtZW50LnRhZ05hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB0YWdOYW1lID0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgaGFzVGFiSW5kZXggPSBCb29sZWFuKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJJbmRleCcpKTtcbiAgICBjb25zdCBmb2N1c2FibGUgPSAhZWxlbWVudC5kaXNhYmxlZCAmJiBmb2N1c2FibGVSZWdleC50ZXN0KHRhZ05hbWUpO1xuICAgIHJldHVybiBmb2N1c2FibGUgfHwgaGFzVGFiSW5kZXg7XG59O1xuXG5jb25zdCBpc1Zpc2libGUgPSAoZWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGhhc1NpemUgPSByZWN0LndpZHRoID4gMCAmJiByZWN0LmhlaWdodCA+IDA7XG4gICAgY29uc3QgaGFzUG9zaXRpb24gPSByZWN0LnggIT09IDAgJiYgcmVjdC55ICE9PSAwO1xuICAgIC8vIEVsZW1lbnRzIGNhbiBoYXZlIHplcm8gc2l6ZSBkdWUgdG8gc3R5bGluZywgYnV0IHRoZXkgd2lsbCBzdGlsbCBjb3VudCBhcyB2aXNpYmxlLlxuICAgIC8vIEZvciBleGFtcGxlLCB0aGUgc2VsZWN0aW9uIGNoZWNrYm94IGhhcyBubyBzaXplLCBidXQgaXMgbWFkZSB2aXNpYmxlIHRocm91Z2ggc3R5bGluZy5cbiAgICByZXR1cm4gKGhhc1NpemUgfHwgaGFzUG9zaXRpb24pICYmIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnZpc2liaWxpdHkgIT09ICdoaWRkZW4nO1xufTtcblxuY29uc3QgaXNGb2N1c2FibGVXaXRoVGFiS2V5ID0gKGVsZW1lbnQsIGNoZWNrVmlzaWJpbGl0eSA9IHRydWUpID0+IHtcbiAgICBpZiAoIWlzRm9jdXNhYmxlKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdGFiSW5kZXggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiSW5kZXgnKTtcbiAgICBjb25zdCB2aXNpYmxlID0gIWNoZWNrVmlzaWJpbGl0eSB8fCBpc1Zpc2libGUoZWxlbWVudCk7XG4gICAgcmV0dXJuIHZpc2libGUgJiYgdGFiSW5kZXggIT09ICctMSc7XG59O1xuXG5jb25zdCBmaW5kRm9jdXNhYmxlQ2hpbGQgPSAoZWxlbWVudCwgY2hlY2tWaXNpYmlsaXR5ID0gdHJ1ZSkgPT4ge1xuICAgIHJldHVybiBmaW5kRWxlbWVudChlbGVtZW50LCAobm9kZSkgPT4gaXNGb2N1c2FibGVXaXRoVGFiS2V5KG5vZGUsIGNoZWNrVmlzaWJpbGl0eSksIGZhbHNlKTtcbn07XG5cbmNvbnN0IGZpbmRGb2N1c2FibGUgPSAoZWxlbWVudCwgY2hlY2tWaXNpYmlsaXR5ID0gdHJ1ZSkgPT4ge1xuICAgIHJldHVybiBmaW5kRWxlbWVudChlbGVtZW50LCAobm9kZSkgPT4gaXNGb2N1c2FibGVXaXRoVGFiS2V5KG5vZGUsIGNoZWNrVmlzaWJpbGl0eSkpO1xufTtcblxuY29uc3QgdG9DbGFzc0xpc3QgPSAoY2xhc3NOYW1lcykgPT4gU3RyaW5nKGNsYXNzTmFtZXMpLnRyaW0oKS5zcGxpdCgnICcpO1xuY29uc3QgaGFzQ2xhc3NlcyA9IChlbGVtZW50LCBjbGFzc05hbWVzKSA9PiB7XG4gICAgY29uc3QgbmFtZXNMaXN0ID0gdG9DbGFzc0xpc3QoY2xhc3NOYW1lcyk7XG4gICAgcmV0dXJuIEJvb2xlYW4odG9DbGFzc0xpc3QoZWxlbWVudC5jbGFzc05hbWUpLmZpbmQoKGNsYXNzTmFtZSkgPT4gbmFtZXNMaXN0LmluZGV4T2YoY2xhc3NOYW1lKSA+PSAwKSk7XG59O1xuXG5jb25zdCBtYXRjaGVzQ2xhc3NlcyA9IChjbGFzc05hbWVzKSA9PiAoZWxlbWVudCkgPT4gaGFzQ2xhc3NlcyhlbGVtZW50LCBjbGFzc05hbWVzKTtcblxuY29uc3QgTk9ERV9OQU1FX1BSRURJQ0FURVMgPSB7fTtcbmNvbnN0IG1hdGNoZXNOb2RlTmFtZSA9IChub2RlTmFtZSkgPT4ge1xuICAgIGlmICghTk9ERV9OQU1FX1BSRURJQ0FURVNbbm9kZU5hbWVdKSB7XG4gICAgICAgIE5PREVfTkFNRV9QUkVESUNBVEVTW25vZGVOYW1lXSA9IChlbGVtZW50KSA9PiBTdHJpbmcoZWxlbWVudC5ub2RlTmFtZSkudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIE5PREVfTkFNRV9QUkVESUNBVEVTW25vZGVOYW1lXTtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplcyBhIHNjcm9sbCBwb3NpdGlvbiB2YWx1ZSBpbiBSVEwgbW9kZS5cbiAqL1xuZnVuY3Rpb24gcnRsU2Nyb2xsUG9zaXRpb24ocG9zaXRpb24sIGVsZW1lbnQsIGluaXRpYWwpIHtcbiAgICBsZXQgcmVzdWx0ID0gcG9zaXRpb247XG4gICAgaWYgKGluaXRpYWwgPCAwKSB7XG4gICAgICAgIHJlc3VsdCA9IC1wb3NpdGlvbjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5pdGlhbCA+IDApIHtcbiAgICAgICAgcmVzdWx0ID0gZWxlbWVudC5zY3JvbGxXaWR0aCAtIGVsZW1lbnQub2Zmc2V0V2lkdGggLSBwb3NpdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyogdHNsaW50OmRpc2FibGU6bm8taW5wdXQtcmVuYW1lICovXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IEV2ZW50c091dHNpZGVBbmd1bGFyRGlyZWN0aXZlID0gY2xhc3MgRXZlbnRzT3V0c2lkZUFuZ3VsYXJEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG5nWm9uZSwgcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5ldmVudHMgPSB7fTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5lbGVtZW50IHx8ICF0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBldmVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCBuYW1lLCB0aGlzLnNjb3BlID8gZXZlbnRzW25hbWVdLmJpbmQodGhpcy5zY29wZSkgOiBldmVudHNbbmFtZV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnNbaWR4XSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgna2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBFdmVudHNPdXRzaWRlQW5ndWxhckRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZXZlbnRzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBFdmVudHNPdXRzaWRlQW5ndWxhckRpcmVjdGl2ZS5wcm90b3R5cGUsIFwic2NvcGVcIiwgdm9pZCAwKTtcbkV2ZW50c091dHNpZGVBbmd1bGFyRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl0nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLFxuICAgICAgICBOZ1pvbmUsXG4gICAgICAgIFJlbmRlcmVyMl0pXG5dLCBFdmVudHNPdXRzaWRlQW5ndWxhckRpcmVjdGl2ZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRXZlbnRzTW9kdWxlID0gY2xhc3MgRXZlbnRzTW9kdWxlIHtcbn07XG5FdmVudHNNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW0V2ZW50c091dHNpZGVBbmd1bGFyRGlyZWN0aXZlXSxcbiAgICAgICAgZXhwb3J0czogW0V2ZW50c091dHNpZGVBbmd1bGFyRGlyZWN0aXZlXVxuICAgIH0pXG5dLCBFdmVudHNNb2R1bGUpO1xuXG5jbGFzcyBSZXNpemVTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNpemVCYXRjaFNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5yZXNpemVCYXRjaFNlcnZpY2UgPSByZXNpemVCYXRjaFNlcnZpY2U7XG4gICAgICAgIHRoaXMucmVzaXplID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmFjY2VwdGVkU2l6ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXRlID0gMCAvKiBJbml0aWFsICovO1xuICAgIH1cbiAgICBhY2NlcHRTaXplKHNpemUgPSB0aGlzLm1lYXN1cmUoKSkge1xuICAgICAgICB0aGlzLmxhc3RXaWR0aCA9IHNpemUud2lkdGg7XG4gICAgICAgIHRoaXMubGFzdEhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICB0aGlzLmFjY2VwdGVkU2l6ZSA9IHRydWU7XG4gICAgfVxuICAgIGNoZWNrQ2hhbmdlcygpIHtcbiAgICAgICAgaWYgKCFpc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gMCAvKiBJbml0aWFsICovKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMSAvKiBJbml0aWFsaXppbmcgKi87XG4gICAgICAgICAgICAvLyBiYXRjaCBpbml0aWFsIG1lYXN1cmVcbiAgICAgICAgICAgIHRoaXMucmVzaXplQmF0Y2hTZXJ2aWNlLnNjaGVkdWxlKHRoaXMsIHRoaXMuaW5pdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZXNpemVCYXRjaFNlcnZpY2UuY2FuY2VsKHRoaXMpO1xuICAgIH1cbiAgICBjaGVja1NpemUoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLm1lYXN1cmUoKTtcbiAgICAgICAgY29uc3Qgc2FtZVNpemUgPSB3aWR0aCA9PT0gdGhpcy5sYXN0V2lkdGggJiYgaGVpZ2h0ID09PSB0aGlzLmxhc3RIZWlnaHQ7XG4gICAgICAgIGlmIChzYW1lU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdFdpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMubGFzdEhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5hY2NlcHRlZFNpemUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXNpemUuZW1pdCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaW5pdFNpemUoKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLm1lYXN1cmUoKTtcbiAgICAgICAgdGhpcy5sYXN0V2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgICB0aGlzLmxhc3RIZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICB9XG4gICAgbWVhc3VyZSgpIHtcbiAgICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgICAgbGV0IGhlaWdodCA9IDA7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMucGFyZW50RWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMucGFyZW50RWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBoZWlnaHQsIHdpZHRoIH07XG4gICAgfVxufVxuXG4vLyB0c2xpbnQ6ZGlzYWJsZTpkZXByZWNhdGlvblxuY29uc3QgZGl2ID0gc3R5bGUgPT4ge1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuc3R5bGUuY3NzVGV4dCA9IHN0eWxlO1xuICAgIHJldHVybiBlbDtcbn07XG5jb25zdCBjb21wdXRlZFByb3AgPSAoZWxlbSwgcHJvcCkgPT4gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApO1xuY29uc3QgV1JBUF9TVFlMRSA9ICdwb3NpdGlvbjogYWJzb2x1dGU7IGRpc3BsYXk6IGJsb2NrOyBsZWZ0OiAwOyB0b3A6IDA7IHJpZ2h0OiAwOyBib3R0b206IDA7IHotaW5kZXg6IC0xOycgK1xuICAgICdvdmVyZmxvdzogaGlkZGVuOyB2aXNpYmlsaXR5OiBoaWRkZW47JztcbmNvbnN0IEVYUEFORF9DSElMRF9TVFlMRSA9ICdwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IDA7IHRvcDogMDsgdHJhbnNpdGlvbjogMHM7JztcbmNvbnN0IFNIUklOS19DSElMRF9TVFlMRSA9IEVYUEFORF9DSElMRF9TVFlMRSArICd3aWR0aDogMjAwJTsgaGVpZ2h0OiAyMDAlOyc7XG5jbGFzcyBSZXNpemVDb21wYXRTZXJ2aWNlIGV4dGVuZHMgUmVzaXplU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IocmVzaXplQmF0Y2hTZXJ2aWNlLCBlbGVtZW50LCBuZ1pvbmUpIHtcbiAgICAgICAgc3VwZXIocmVzaXplQmF0Y2hTZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgfVxuICAgIGNoZWNrQ2hhbmdlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IDIgLyogSW5pdGlhbGl6ZWQgKi8pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZXNpemVCYXRjaFNlcnZpY2UuaXNTY2hlZHVsZWQodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZUJhdGNoU2VydmljZS5zY2hlZHVsZSh0aGlzLCB0aGlzLmNoZWNrU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuY2hlY2tDaGFuZ2VzKCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4cGFuZCkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLmV4cGFuZCk7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuc2hyaW5rKTtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kLnJlbW92ZUNoaWxkKHRoaXMuZXhwYW5kQ2hpbGQpO1xuICAgICAgICAgICAgdGhpcy5leHBhbmQgPSB0aGlzLmV4cGFuZENoaWxkID0gdGhpcy5zaHJpbmsgPSB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrU2l6ZSgpIHtcbiAgICAgICAgaWYgKHN1cGVyLmNoZWNrU2l6ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICBjb25zdCBwYXJlbnRFbGVtZW50ID0gdGhpcy5wYXJlbnRFbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgaWYgKGNvbXB1dGVkUHJvcChwYXJlbnRFbGVtZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICAgIHBhcmVudEVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSAyIC8qIEluaXRpYWxpemVkICovO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuaW5pdFNpemUoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFdSQVBfU1RZTEU7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkaXInLCAnbHRyJyk7XG4gICAgICAgIHRoaXMuZXhwYW5kID0gZGl2KFdSQVBfU1RZTEUpO1xuICAgICAgICB0aGlzLmV4cGFuZENoaWxkID0gZGl2KEVYUEFORF9DSElMRF9TVFlMRSk7XG4gICAgICAgIHRoaXMuZXhwYW5kLmFwcGVuZENoaWxkKHRoaXMuZXhwYW5kQ2hpbGQpO1xuICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuZXhwYW5kKTtcbiAgICAgICAgdGhpcy5zaHJpbmsgPSBkaXYoV1JBUF9TVFlMRSk7XG4gICAgICAgIGNvbnN0IHNocmlua0NoaWxkID0gZGl2KFNIUklOS19DSElMRF9TVFlMRSk7XG4gICAgICAgIHRoaXMuc2hyaW5rLmFwcGVuZENoaWxkKHNocmlua0NoaWxkKTtcbiAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNocmluayk7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICBjb25zdCBleHBhbmRDaGlsZCA9IHRoaXMuZXhwYW5kQ2hpbGQ7XG4gICAgICAgIGV4cGFuZENoaWxkLnN0eWxlLndpZHRoID0gMTAwMDAwICsgJ3B4JztcbiAgICAgICAgZXhwYW5kQ2hpbGQuc3R5bGUuaGVpZ2h0ID0gMTAwMDAwICsgJ3B4JztcbiAgICAgICAgY29uc3QgZXhwYW5kID0gdGhpcy5leHBhbmQ7XG4gICAgICAgIGV4cGFuZC5zY3JvbGxMZWZ0ID0gMTAwMDAwO1xuICAgICAgICBleHBhbmQuc2Nyb2xsVG9wID0gMTAwMDAwO1xuICAgICAgICBjb25zdCBzaHJpbmsgPSB0aGlzLnNocmluaztcbiAgICAgICAgc2hyaW5rLnNjcm9sbExlZnQgPSAxMDAwMDA7XG4gICAgICAgIHNocmluay5zY3JvbGxUb3AgPSAxMDAwMDA7XG4gICAgfVxuICAgIHN1YnNjcmliZSgpIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSBtZXJnZShmcm9tRXZlbnQodGhpcy5zaHJpbmssICdzY3JvbGwnKSwgZnJvbUV2ZW50KHRoaXMuZXhwYW5kLCAnc2Nyb2xsJykpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1NpemUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNvbnN0IEhBU19PQlNFUlZFUiA9IHR5cGVvZiBSZXNpemVPYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCc7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUmVzaXplT2JzZXJ2ZXJTZXJ2aWNlIGV4dGVuZHMgUmVzaXplU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IocmVzaXplQmF0Y2hTZXJ2aWNlLCBlbGVtZW50LCBuZ1pvbmUpIHtcbiAgICAgICAgc3VwZXIocmVzaXplQmF0Y2hTZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgfVxuICAgIHN0YXRpYyBzdXBwb3J0ZWQoKSB7XG4gICAgICAgIHJldHVybiBIQVNfT0JTRVJWRVI7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMucmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJlbnRFbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRFbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgdGhpcy5pbml0U2l6ZSgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gMiAvKiBJbml0aWFsaXplZCAqLztcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1NpemUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMucGFyZW50RWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBSZXNpemVCYXRjaFNlcnZpY2UgPSBjbGFzcyBSZXNpemVCYXRjaFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKG5nWm9uZSkge1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWQgPSBbXTtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIHRoaXMuZmx1c2ggPSB0aGlzLmZsdXNoLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIHNjaGVkdWxlKGluc3RhbmNlLCBtZXRob2QpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWQucHVzaCh7IGluc3RhbmNlLCBtZXRob2QgfSk7XG4gICAgICAgIGlmICghdGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IGZyb20odGhpcy5yZXNvbHZlZFByb21pc2UpXG4gICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5mbHVzaCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1NjaGVkdWxlZChpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLnNjaGVkdWxlZC5maW5kKGl0ZW0gPT4gaXRlbS5pbnN0YW5jZSA9PT0gaW5zdGFuY2UpKTtcbiAgICB9XG4gICAgY2FuY2VsKGluc3RhbmNlKSB7XG4gICAgICAgIGNvbnN0IHNjaGVkdWxlZCA9IHRoaXMuc2NoZWR1bGVkO1xuICAgICAgICBjb25zdCBjb3VudCA9IHNjaGVkdWxlZC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGNvdW50OyBpZHgrKykge1xuICAgICAgICAgICAgaWYgKHNjaGVkdWxlZFtpZHhdLmluc3RhbmNlID09PSBpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlZC5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNjaGVkdWxlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbHVzaCgpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWQuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGl0ZW0ubWV0aG9kLmNhbGwoaXRlbS5pbnN0YW5jZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNjaGVkdWxlZCA9IFtdO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxufTtcblJlc2l6ZUJhdGNoU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05nWm9uZV0pXG5dLCBSZXNpemVCYXRjaFNlcnZpY2UpO1xuXG4vKipcbiAqIEVtaXQgdXAgdG8gMTAgcmVzaXplIGV2ZW50cyBwZXIgc2Vjb25kIGJ5IGRlZmF1bHQuXG4gKiBDaG9zZW4gYXMgYSBjb21wcm9taXNlIGJldHdlZW4gcmVzcG9uc2l2ZW5lc3MgYW5kIHBlcmZvcm1hbmNlLlxuICovXG5jb25zdCBERUZBVUxUX1JBVEVfTElNSVQgPSAxMDtcbi8qKlxuICogUmVzaXplIFNlbnNvciBDb21wb25lbnRcbiAqXG4gKiBUcmlnZ2VycyBhIFwicmVzaXplXCIgZXZlbnQgd2hlbmV2ZXIgdGhlIHBhcmVudCBET00gZWxlbWVudCBzaXplIGNoYW5nZXMuXG4gKi9cbmxldCBSZXNpemVTZW5zb3JDb21wb25lbnQgPSBjbGFzcyBSZXNpemVTZW5zb3JDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHJlc2l6ZUJhdGNoU2VydmljZSwgZWxlbWVudCwgbmdab25lKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmVzaXplIGV2ZW50cyB0byBlbWl0IHBlciBzZWNvbmQuXG4gICAgICAgICAqXG4gICAgICAgICAqIERlZmF1bHRzIHRvIDEwLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYXRlTGltaXQgPSBERUZBVUxUX1JBVEVfTElNSVQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBwYXJlbnQgRE9NIGVsZW1lbnQgaGFzIGJlZW4gcmVzaXplZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzaXplID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBjb25zdCBzZXJ2aWNlVHlwZSA9IFJlc2l6ZU9ic2VydmVyU2VydmljZS5zdXBwb3J0ZWQoKSA/IFJlc2l6ZU9ic2VydmVyU2VydmljZSA6IFJlc2l6ZUNvbXBhdFNlcnZpY2U7XG4gICAgICAgIHRoaXMucmVzaXplU2VydmljZSA9IG5ldyBzZXJ2aWNlVHlwZShyZXNpemVCYXRjaFNlcnZpY2UsIGVsZW1lbnQsIG5nWm9uZSk7XG4gICAgICAgIGNvbnN0IHRocm90dGxlVGltZSA9IDEwMDAgLyAodGhpcy5yYXRlTGltaXQgfHwgREVGQVVMVF9SQVRFX0xJTUlUKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLnJlc2l6ZVNlcnZpY2UucmVzaXplXG4gICAgICAgICAgICAucGlwZShhdWRpdFRpbWUodGhyb3R0bGVUaW1lKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlc2l6ZVNlcnZpY2UuYWNjZXB0ZWRTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemUuZW1pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdDaGVja2VkKCkge1xuICAgICAgICB0aGlzLnJlc2l6ZVNlcnZpY2UuY2hlY2tDaGFuZ2VzKCk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnJlc2l6ZVNlcnZpY2UuZGVzdHJveSgpO1xuICAgIH1cbiAgICBhY2NlcHRTaXplKHNpemUpIHtcbiAgICAgICAgdGhpcy5yZXNpemVTZXJ2aWNlLmFjY2VwdFNpemUoc2l6ZSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFJlc2l6ZVNlbnNvckNvbXBvbmVudC5wcm90b3R5cGUsIFwicmF0ZUxpbWl0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgUmVzaXplU2Vuc29yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyZXNpemVcIiwgdm9pZCAwKTtcblJlc2l6ZVNlbnNvckNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tcmVzaXplLXNlbnNvcicsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbUmVzaXplQmF0Y2hTZXJ2aWNlLCBFbGVtZW50UmVmLCBOZ1pvbmVdKVxuXSwgUmVzaXplU2Vuc29yQ29tcG9uZW50KTtcblxuY29uc3QgQ09NUE9ORU5UX0RJUkVDVElWRVMgPSBbUmVzaXplU2Vuc29yQ29tcG9uZW50XTtcbi8qKlxuICogUmVzaXplIFNlbnNvciBtb2R1bGVcbiAqL1xubGV0IFJlc2l6ZVNlbnNvck1vZHVsZSA9IGNsYXNzIFJlc2l6ZVNlbnNvck1vZHVsZSB7XG59O1xuUmVzaXplU2Vuc29yTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtDT01QT05FTlRfRElSRUNUSVZFU10sXG4gICAgICAgIGV4cG9ydHM6IFtDT01QT05FTlRfRElSRUNUSVZFU10sXG4gICAgICAgIHByb3ZpZGVyczogW1Jlc2l6ZUJhdGNoU2VydmljZV1cbiAgICB9KVxuXSwgUmVzaXplU2Vuc29yTW9kdWxlKTtcblxuY2xhc3MgS2VuZG9JbnB1dCB7XG59XG5cbi8qKlxuICogRW51bSB3aXRoIGtleSBjb2Rlcy5cbiAqL1xudmFyIEtleXM7XG4oZnVuY3Rpb24gKEtleXMpIHtcbiAgICBLZXlzW0tleXNbXCJBbHRcIl0gPSAxOF0gPSBcIkFsdFwiO1xuICAgIEtleXNbS2V5c1tcIkFycm93RG93blwiXSA9IDQwXSA9IFwiQXJyb3dEb3duXCI7XG4gICAgS2V5c1tLZXlzW1wiQXJyb3dMZWZ0XCJdID0gMzddID0gXCJBcnJvd0xlZnRcIjtcbiAgICBLZXlzW0tleXNbXCJBcnJvd1JpZ2h0XCJdID0gMzldID0gXCJBcnJvd1JpZ2h0XCI7XG4gICAgS2V5c1tLZXlzW1wiQXJyb3dVcFwiXSA9IDM4XSA9IFwiQXJyb3dVcFwiO1xuICAgIEtleXNbS2V5c1tcIkJhY2tzcGFjZVwiXSA9IDhdID0gXCJCYWNrc3BhY2VcIjtcbiAgICBLZXlzW0tleXNbXCJDb250cm9sXCJdID0gMTddID0gXCJDb250cm9sXCI7XG4gICAgS2V5c1tLZXlzW1wiRGVsZXRlXCJdID0gNDZdID0gXCJEZWxldGVcIjtcbiAgICBLZXlzW0tleXNbXCJEaWdpdDBcIl0gPSA0OF0gPSBcIkRpZ2l0MFwiO1xuICAgIEtleXNbS2V5c1tcIkRpZ2l0MVwiXSA9IDQ5XSA9IFwiRGlnaXQxXCI7XG4gICAgS2V5c1tLZXlzW1wiRGlnaXQyXCJdID0gNTBdID0gXCJEaWdpdDJcIjtcbiAgICBLZXlzW0tleXNbXCJEaWdpdDNcIl0gPSA1MV0gPSBcIkRpZ2l0M1wiO1xuICAgIEtleXNbS2V5c1tcIkRpZ2l0NFwiXSA9IDUyXSA9IFwiRGlnaXQ0XCI7XG4gICAgS2V5c1tLZXlzW1wiRGlnaXQ1XCJdID0gNTNdID0gXCJEaWdpdDVcIjtcbiAgICBLZXlzW0tleXNbXCJEaWdpdDZcIl0gPSA1NF0gPSBcIkRpZ2l0NlwiO1xuICAgIEtleXNbS2V5c1tcIkRpZ2l0N1wiXSA9IDU1XSA9IFwiRGlnaXQ3XCI7XG4gICAgS2V5c1tLZXlzW1wiRGlnaXQ4XCJdID0gNTZdID0gXCJEaWdpdDhcIjtcbiAgICBLZXlzW0tleXNbXCJEaWdpdDlcIl0gPSA1N10gPSBcIkRpZ2l0OVwiO1xuICAgIEtleXNbS2V5c1tcIkVuZFwiXSA9IDM1XSA9IFwiRW5kXCI7XG4gICAgS2V5c1tLZXlzW1wiRW50ZXJcIl0gPSAxM10gPSBcIkVudGVyXCI7XG4gICAgS2V5c1tLZXlzW1wiRXNjYXBlXCJdID0gMjddID0gXCJFc2NhcGVcIjtcbiAgICBLZXlzW0tleXNbXCJGMVwiXSA9IDExMl0gPSBcIkYxXCI7XG4gICAgS2V5c1tLZXlzW1wiRjJcIl0gPSAxMTNdID0gXCJGMlwiO1xuICAgIEtleXNbS2V5c1tcIkYxMFwiXSA9IDEyMV0gPSBcIkYxMFwiO1xuICAgIEtleXNbS2V5c1tcIkhvbWVcIl0gPSAzNl0gPSBcIkhvbWVcIjtcbiAgICBLZXlzW0tleXNbXCJJbnNlcnRcIl0gPSA0NV0gPSBcIkluc2VydFwiO1xuICAgIEtleXNbS2V5c1tcIktleUFcIl0gPSA2NV0gPSBcIktleUFcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlCXCJdID0gNjZdID0gXCJLZXlCXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5Q1wiXSA9IDY3XSA9IFwiS2V5Q1wiO1xuICAgIEtleXNbS2V5c1tcIktleURcIl0gPSA2OF0gPSBcIktleURcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlFXCJdID0gNjldID0gXCJLZXlFXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5RlwiXSA9IDcwXSA9IFwiS2V5RlwiO1xuICAgIEtleXNbS2V5c1tcIktleUdcIl0gPSA3MV0gPSBcIktleUdcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlIXCJdID0gNzJdID0gXCJLZXlIXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5SVwiXSA9IDczXSA9IFwiS2V5SVwiO1xuICAgIEtleXNbS2V5c1tcIktleUpcIl0gPSA3NF0gPSBcIktleUpcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlLXCJdID0gNzVdID0gXCJLZXlLXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5TFwiXSA9IDc2XSA9IFwiS2V5TFwiO1xuICAgIEtleXNbS2V5c1tcIktleU1cIl0gPSA3N10gPSBcIktleU1cIjtcbiAgICBLZXlzW0tleXNbXCJLZXlOXCJdID0gNzhdID0gXCJLZXlOXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5T1wiXSA9IDc5XSA9IFwiS2V5T1wiO1xuICAgIEtleXNbS2V5c1tcIktleVBcIl0gPSA4MF0gPSBcIktleVBcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlRXCJdID0gODFdID0gXCJLZXlRXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5UlwiXSA9IDgyXSA9IFwiS2V5UlwiO1xuICAgIEtleXNbS2V5c1tcIktleVNcIl0gPSA4M10gPSBcIktleVNcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlUXCJdID0gODRdID0gXCJLZXlUXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5VVwiXSA9IDg1XSA9IFwiS2V5VVwiO1xuICAgIEtleXNbS2V5c1tcIktleVZcIl0gPSA4Nl0gPSBcIktleVZcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlXXCJdID0gODddID0gXCJLZXlXXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5WFwiXSA9IDg4XSA9IFwiS2V5WFwiO1xuICAgIEtleXNbS2V5c1tcIktleVlcIl0gPSA4OV0gPSBcIktleVlcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlaXCJdID0gOTBdID0gXCJLZXlaXCI7XG4gICAgS2V5c1tLZXlzW1wiTnVtcGFkRGVjaW1hbFwiXSA9IDExMF0gPSBcIk51bXBhZERlY2ltYWxcIjtcbiAgICBLZXlzW0tleXNbXCJQYWdlRG93blwiXSA9IDM0XSA9IFwiUGFnZURvd25cIjtcbiAgICBLZXlzW0tleXNbXCJQYWdlVXBcIl0gPSAzM10gPSBcIlBhZ2VVcFwiO1xuICAgIEtleXNbS2V5c1tcIlNoaWZ0XCJdID0gMTZdID0gXCJTaGlmdFwiO1xuICAgIEtleXNbS2V5c1tcIlNwYWNlXCJdID0gMzJdID0gXCJTcGFjZVwiO1xuICAgIEtleXNbS2V5c1tcIlRhYlwiXSA9IDldID0gXCJUYWJcIjtcbn0pKEtleXMgfHwgKEtleXMgPSB7fSkpO1xuXG5jbGFzcyBQcmV2ZW50YWJsZUV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJldmVudHMgdGhlIGRlZmF1bHQgYWN0aW9uIGZvciBhIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBJbiB0aGlzIHdheSwgdGhlIHNvdXJjZSBjb21wb25lbnQgc3VwcHJlc3Nlc1xuICAgICAqIHRoZSBidWlsdC1pbiBiZWhhdmlvciB0aGF0IGZvbGxvd3MgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICB0aGlzLnByZXZlbnRlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBldmVudCB3YXMgcHJldmVudGVkXG4gICAgICogYnkgYW55IG9mIGl0cyBzdWJzY3JpYmVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZGVmYXVsdCBhY3Rpb24gd2FzIHByZXZlbnRlZC5cbiAgICAgKiBPdGhlcndpc2UsIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBpc0RlZmF1bHRQcmV2ZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZlbnRlZDtcbiAgICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cblxuZXhwb3J0IHsgUmVzaXplU2VydmljZSwgUHJldmVudGFibGVFdmVudCwgRHJhZ2dhYmxlRGlyZWN0aXZlLCBEcmFnZ2FibGVNb2R1bGUsIGNsb3Nlc3RJblNjb3BlLCBjbG9zZXN0LCBjb250YWlucywgZmluZEVsZW1lbnQsIGZpbmRGb2N1c2FibGVDaGlsZCwgZmluZEZvY3VzYWJsZSwgaGFzQ2xhc3NlcywgaXNGb2N1c2FibGVXaXRoVGFiS2V5LCBpc0ZvY3VzYWJsZSwgaXNWaXNpYmxlLCBtYXRjaGVzQ2xhc3NlcywgbWF0Y2hlc05vZGVOYW1lLCBydGxTY3JvbGxQb3NpdGlvbiwgRXZlbnRzT3V0c2lkZUFuZ3VsYXJEaXJlY3RpdmUsIEV2ZW50c01vZHVsZSwgUmVzaXplU2Vuc29yQ29tcG9uZW50LCBSZXNpemVCYXRjaFNlcnZpY2UsIFJlc2l6ZUNvbXBhdFNlcnZpY2UsIFJlc2l6ZU9ic2VydmVyU2VydmljZSwgUmVzaXplU2Vuc29yTW9kdWxlLCBLZW5kb0lucHV0LCBpc0RvY3VtZW50QXZhaWxhYmxlLCBpc0NoYW5nZWQsIGFueUNoYW5nZWQsIGhhc09ic2VydmVycywgZ3VpZCwgS2V5cyB9O1xuIl19","map":null,"metadata":{},"sourceType":"module"}